{"version":3,"file":"159.c5ab8d7f.iframe.bundle.js","mappings":";;AAgCA;AACA;AAMA;AACA;;AAEA;AANA;;AA+BA;AACA;;AAGA;;AAMA;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AChFA;AACA;AAIA;AAKA;;;;;AAOA;;;;;;AAOA;ACmFA;AACA;AA0MA;;AAGA;;;;AAQA;;AAIA;;AAIA;;;AAGA;;;;;;AAMA;;;AAIA;ACzVA;AACA;;;;;;AAuBA","sources":["webpack://@stylospectrum/ui/./src/button/index.ts","webpack://@stylospectrum/ui/./src/list/list-item.ts","webpack://@stylospectrum/ui/./src/popover/index.ts","webpack://@stylospectrum/ui/./src/tooltip/index.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, render } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ButtonDesign, ButtonType } from '../types';\nimport styles from './style/index.scss';\nimport '../icon';\nimport '../tooltip';\nlet Button = class Button extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {ButtonDesign}\n         * @defaultValue \"Primary\"\n         * @public\n         */\n        this.type = ButtonDesign.Primary;\n        /**\n         * Defines whether the button has special form-related functionality.\n         *\n         * @type {ButtonType}\n         * @defaultValue \"Button\"\n         * @public\n         */\n        this.htmlType = ButtonType.Button;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    tooltipTemplate(hovered = false) {\n        if (!hovered) {\n            return nothing;\n        }\n        return html `<stylospectrum-tooltip\n      openerRect=${JSON.stringify(this.getBoundingClientRect())}\n      placement=${this.tooltipPlacement}\n    >\n      ${this.tooltip}\n    </stylospectrum-tooltip>`;\n    }\n    handleFocusIn() {\n        this.focused = true;\n    }\n    handleFocusOut() {\n        this.focused = false;\n    }\n    handleMouseEnter() {\n        if (!this.tooltip) {\n            return;\n        }\n        render(this.tooltipTemplate(true), document.body);\n    }\n    handleMouseLeave() {\n        if (!this.tooltip) {\n            return;\n        }\n        render(this.tooltipTemplate(), document.body);\n    }\n    render() {\n        const iconNode = this.icon\n            ? html `<stylospectrum-icon\n          class=\"stylospectrum-button-icon\"\n          name=${this.icon}\n          rotate=${this.iconRotate}\n        >\n        </stylospectrum-icon>`\n            : html `<slot name=\"icon\"></slot>`;\n        const textNode = this.icon\n            ? nothing\n            : html `<span class=\"stylospectrum-button-text\">\n          <slot></slot>\n        </span>`;\n        const classes = {\n            'stylospectrum-button': true,\n            'stylospectrum-button-has-icon': !!this.icon,\n        };\n        return html `\n      <button\n        ?disabled=${this.disabled}\n        type=${this.htmlType.toLowerCase()}\n        part=\"button\"\n        class=${classMap(classes)}\n        @focusout=${this.handleFocusOut}\n        @focusin=${this.handleFocusIn}\n        @mouseenter=${this.handleMouseEnter}\n        @mouseleave=${this.handleMouseLeave}\n      >\n        ${textNode} ${iconNode}\n      </button>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"icon\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"iconRotate\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"tooltip\", void 0);\n__decorate([\n    property({ type: String, attribute: 'tooltip-placement' })\n], Button.prototype, \"tooltipPlacement\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Button.prototype, \"type\", void 0);\n__decorate([\n    property({ type: String, attribute: 'html-type', reflect: true })\n], Button.prototype, \"htmlType\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"focused\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"circle\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true, attribute: 'tab-selected' })\n], Button.prototype, \"tabSelected\", void 0);\nButton = __decorate([\n    customElement('stylospectrum-button')\n], Button);\nexport default Button;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { consume } from '@lit/context';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { listContext } from './context';\nimport styles from './style/list-item.scss';\nimport '../icon';\nlet ListItem = class ListItem extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    render() {\n        const selected = this._consumer?.selectedId === this.id;\n        return html `<li\n      class=${classMap({\n            'stylospectrum-list-item': true,\n            'stylospectrum-list-item-selected': selected,\n            'stylospectrum-list-item-focused': this.focused,\n        })}\n      @click=${() => {\n            this._consumer?.onChangeId?.(this.id);\n        }}\n    >\n      <span class=\"stylospectrum-list-item-icon-wrapper\">\n        <stylospectrum-icon\n          class=\"stylospectrum-list-item-icon\"\n          name=\"${this.icon}\"\n        >\n        </stylospectrum-icon>\n      </span>\n\n      <span class=\"stylospectrum-list-item-text\"><slot></slot></span>\n    </li>`;\n    }\n};\n__decorate([\n    property({ type: String })\n], ListItem.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItem.prototype, \"focused\", void 0);\n__decorate([\n    consume({ context: listContext, subscribe: true })\n], ListItem.prototype, \"_consumer\", void 0);\nListItem = __decorate([\n    customElement('stylospectrum-list-item')\n], ListItem);\nexport default ListItem;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Popover_1;\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property, query, state } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { Placement, PopoverHorizontalAlign } from '../types';\nimport clamp from '../utils/clamp';\nimport getParentElement from '../utils/getParentElement';\nimport isElementContainingBlock from '../utils/isElementContainingBlock';\nimport { getFocusedElement, isClickInRect } from '../utils/popup';\nimport { getFirstFocusableElement } from '../utils/focusableElements';\nconst ARROW_SIZE = 8;\nconst openedRegistry = [];\nlet Popover = class Popover extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Determines on which side the component is placed at.\n         *\n         * @default \"Right\"\n         * @public\n         */\n        this.placement = Placement.Bottom;\n        /**\n         * Determines the horizontal alignment of the component.\n         *\n         * @type {PopoverHorizontalAlign}\n         * @defaultValue \"Center\"\n         * @public\n         */\n        this.horizontalAlign = PopoverHorizontalAlign.Center;\n        /**\n         * @type {number}\n         * @defaultValue 0\n         * @private\n         */\n        this.offsetX = 0;\n        this.arrowTranslateX = 0;\n        this.arrowTranslateY = 0;\n        this.opened = false;\n        this._clickHandler = (event) => {\n            const openedPopups = [...openedRegistry];\n            if (openedPopups.length === 0) {\n                return;\n            }\n            const isTopPopupPopover = openedPopups[openedPopups.length - 1].instance instanceof Popover_1;\n            if (!isTopPopupPopover) {\n                return;\n            }\n            for (let i = openedPopups.length - 1; i !== -1; i--) {\n                const popup = openedPopups[i].instance;\n                if (popup._isOpenerClicked(event)) {\n                    return;\n                }\n                if (isClickInRect(event, popup.popup.getBoundingClientRect())) {\n                    break;\n                }\n                popup.hide();\n            }\n        };\n        this._attachGlobalClickHandler = () => {\n            document.addEventListener('mousedown', this._clickHandler);\n        };\n        this._detachGlobalClickHandler = () => {\n            document.removeEventListener('mousedown', this._clickHandler);\n        };\n        this._getParentPopoversIfNested = (instance) => {\n            let currentElement = instance.parentNode;\n            const parentPopovers = [];\n            while (currentElement && currentElement.parentNode) {\n                for (let i = 0; i < openedRegistry.length; i++) {\n                    if (currentElement === openedRegistry[i].instance) {\n                        parentPopovers.push(currentElement);\n                    }\n                }\n                currentElement = currentElement.parentNode;\n            }\n            return parentPopovers;\n        };\n        this._addOpenedPopover = (instance) => {\n            const parentPopovers = this._getParentPopoversIfNested(instance);\n            openedRegistry.push({\n                instance,\n                parentPopovers,\n            });\n            if (openedRegistry.length === 1) {\n                this._attachGlobalClickHandler();\n            }\n        };\n        this._removeOpenedPopover = (instance) => {\n            const popoversToClose = [instance];\n            for (let i = 0; i < openedRegistry.length; i++) {\n                const indexOfCurrentInstance = openedRegistry[i].parentPopovers.indexOf(instance);\n                if (openedRegistry[i].parentPopovers.length > 0 &&\n                    indexOfCurrentInstance > -1) {\n                    popoversToClose.push(openedRegistry[i].instance);\n                }\n            }\n            for (let i = popoversToClose.length - 1; i >= 0; i--) {\n                for (let j = 0; j < openedRegistry.length; j++) {\n                    let indexOfItemToRemove = -1;\n                    if (popoversToClose[i] === openedRegistry[j].instance) {\n                        indexOfItemToRemove = j;\n                    }\n                    if (indexOfItemToRemove >= 0) {\n                        const itemToClose = openedRegistry.splice(indexOfItemToRemove, 1);\n                        itemToClose[0].instance.hide();\n                    }\n                }\n            }\n            if (!openedRegistry.length) {\n                this._detachGlobalClickHandler();\n            }\n        };\n    }\n    static { Popover_1 = this; }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    static get VIEWPORT_MARGIN() {\n        return 10; // px\n    }\n    _isOpenerClicked(e) {\n        const target = e.target;\n        if (target === this._opener) {\n            return true;\n        }\n        return e.composedPath().indexOf(this._opener) > -1;\n    }\n    _getContainingBlockClientLocation() {\n        let parentElement = getParentElement(this);\n        while (parentElement) {\n            if (isElementContainingBlock(parentElement)) {\n                return parentElement.getBoundingClientRect();\n            }\n            parentElement = getParentElement(parentElement);\n        }\n        return { left: 0, top: 0 };\n    }\n    _getPopupSize() {\n        const rect = this.popup.getBoundingClientRect(), width = rect.width, height = rect.height;\n        return { width, height };\n    }\n    _getVerticalLeft(targetRect, popoverSize) {\n        let left = 0;\n        switch (this.horizontalAlign) {\n            case PopoverHorizontalAlign.Left:\n                left = targetRect.left;\n                break;\n            case PopoverHorizontalAlign.Center:\n                left = targetRect.left - (popoverSize.width - targetRect.width) / 2;\n                break;\n            case PopoverHorizontalAlign.Right:\n                left = targetRect.right - popoverSize.width + this.offsetX;\n                break;\n        }\n        return left;\n    }\n    _getHorizontalTop(targetRect, popoverSize) {\n        return targetRect.top - (popoverSize.height - targetRect.height) / 2;\n    }\n    _getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius) {\n        let arrowXCentered = this.horizontalAlign === PopoverHorizontalAlign.Center;\n        if (this.horizontalAlign === PopoverHorizontalAlign.Right &&\n            left <= targetRect.left) {\n            arrowXCentered = true;\n        }\n        let arrowTranslateX = 0;\n        if (isVertical && arrowXCentered) {\n            arrowTranslateX =\n                targetRect.left + targetRect.width / 2 - left - popoverSize.width / 2;\n        }\n        let arrowTranslateY = 0;\n        const safeRangeForArrowY = popoverSize.height / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateY = clamp(arrowTranslateY, -safeRangeForArrowY, safeRangeForArrowY);\n        const safeRangeForArrowX = popoverSize.width / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateX = clamp(arrowTranslateX, -safeRangeForArrowX, safeRangeForArrowX);\n        return {\n            x: Math.round(arrowTranslateX),\n            y: Math.round(arrowTranslateY),\n        };\n    }\n    /**\n     * Fallbacks to new placement, prioritizing <code>Left</code> and <code>Right</code> placements.\n     * @private\n     */\n    _fallbackPlacement(clientWidth, clientHeight, targetRect, popoverSize) {\n        if (targetRect.left > popoverSize.width) {\n            return Placement.Left;\n        }\n        if (clientWidth - targetRect.right > targetRect.left) {\n            return Placement.Right;\n        }\n        if (clientHeight - targetRect.bottom > popoverSize.height) {\n            return Placement.Bottom;\n        }\n        if (clientHeight - targetRect.bottom < targetRect.top) {\n            return Placement.Top;\n        }\n        return undefined;\n    }\n    _getActualPlacement(targetRect, popoverSize) {\n        let actualPlacement = this.placement;\n        const clientWidth = document.documentElement.clientWidth;\n        const clientHeight = document.documentElement.clientHeight;\n        switch (this.placement) {\n            case Placement.Bottom:\n                if (clientHeight - targetRect.bottom < popoverSize.height &&\n                    clientHeight - targetRect.bottom < targetRect.top) {\n                    actualPlacement = Placement.Top;\n                }\n                break;\n            case Placement.Left:\n                if (targetRect.left < popoverSize.width) {\n                    actualPlacement =\n                        this._fallbackPlacement(clientWidth, clientHeight, targetRect, popoverSize) || this.placement;\n                }\n                break;\n        }\n        return actualPlacement;\n    }\n    _calcPlacement(targetRect, popoverSize) {\n        let left = 0;\n        let top = 0;\n        const clientWidth = document.documentElement.clientWidth;\n        const isVertical = this.placement === Placement.Bottom;\n        const arrowOffset = this.hideArrow ? 0 : ARROW_SIZE;\n        const placement = this._getActualPlacement(targetRect, popoverSize);\n        switch (placement) {\n            case Placement.Bottom:\n                left = this._getVerticalLeft(targetRect, popoverSize);\n                top = targetRect.bottom + arrowOffset;\n                break;\n            case Placement.Left:\n                left = Math.max(targetRect.left - popoverSize.width - arrowOffset, 0);\n                top = this._getHorizontalTop(targetRect, popoverSize);\n                break;\n        }\n        if (isVertical) {\n            if (popoverSize.width > clientWidth || left < 0) {\n                left = 0;\n            }\n            else if (left + popoverSize.width > clientWidth) {\n                left -= left + popoverSize.width - clientWidth;\n            }\n        }\n        if (this._left === undefined || Math.abs(this._left - left) > 1.5) {\n            this._left = Math.round(left);\n        }\n        if (this._top === undefined || Math.abs(this._top - top) > 1.5) {\n            this._top = Math.round(top);\n        }\n        const borderRadius = Number.parseInt(window.getComputedStyle(this).getPropertyValue('border-radius'));\n        const arrowPos = this._getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius);\n        return {\n            arrow: arrowPos,\n            top: this._top,\n            left: this._left,\n        };\n    }\n    _resetFocus() {\n        if (!this._focusedElementBeforeOpen) {\n            return;\n        }\n        this._focusedElementBeforeOpen.focus();\n        this._focusedElementBeforeOpen = null;\n    }\n    showAt(opener) {\n        this._opener = opener;\n        this.show();\n    }\n    show() {\n        if (this.opened) {\n            return;\n        }\n        this.style.display = 'block';\n        const popupSize = this._getPopupSize();\n        const openerRect = this._opener.getBoundingClientRect();\n        if (popupSize.width === 0 || popupSize.height === 0) {\n            return;\n        }\n        const placement = this._calcPlacement(openerRect, popupSize);\n        let left = clamp(this._left, Popover_1.VIEWPORT_MARGIN, document.documentElement.clientWidth -\n            popupSize.width -\n            Popover_1.VIEWPORT_MARGIN);\n        let top = clamp(this._top, Popover_1.VIEWPORT_MARGIN, document.documentElement.clientHeight -\n            popupSize.height -\n            Popover_1.VIEWPORT_MARGIN);\n        top = Math.max(top, this._top);\n        this.arrowTranslateX = placement.arrow.x;\n        this.arrowTranslateY = placement.arrow.y;\n        const containingBlockClientLocation = this._getContainingBlockClientLocation();\n        left -= containingBlockClientLocation.left;\n        top -= containingBlockClientLocation.top;\n        this._addOpenedPopover(this);\n        this.opened = true;\n        this._focusedElementBeforeOpen = getFocusedElement();\n        const ele = getFirstFocusableElement(this);\n        ele?.focus();\n        Object.assign(this.popup.style, {\n            top: `${top}px`,\n            left: `${left}px`,\n        });\n    }\n    hide() {\n        if (!this.opened) {\n            return;\n        }\n        this._removeOpenedPopover(this);\n        this.opened = false;\n        this._resetFocus();\n        this.style.display = 'none';\n        Object.assign(this.popup.style, {\n            top: '-10000px',\n            left: '-10000px',\n        });\n    }\n    render() {\n        const headerNode = this.headerText\n            ? html `<header class=\"stylospectrum-popover-header\" part=\"header\">\n          <h1 class=\"stylospectrum-popover-header-text\">${this.headerText}</h1>\n          <slot name=\"sub-header\"></slot>\n        </header>`\n            : nothing;\n        const footerNode = this.hideFooter\n            ? nothing\n            : html `<footer part=\"footer\" class=\"stylospectrum-popover-footer\">\n          <div class=\"stylospectrum-popover-footer-space\"></div>\n          <slot name=\"ok-button\"></slot>\n          <slot name=\"cancel-button\"></slot>\n        </footer>`;\n        const arrowNode = this.hideArrow\n            ? nothing\n            : html `<span\n          class=\"stylospectrum-popover-arrow\"\n          style=\"transform:translate(${this.arrowTranslateX}px, ${this\n                .arrowTranslateY}px)\"\n        >\n        </span>`;\n        return html `\n      <div class=\"stylospectrum-popover-wrapper\">\n        <section class=\"stylospectrum-popover\">\n          ${arrowNode} ${headerNode}\n\n          <div part=\"content\" class=\"stylospectrum-popover-content\">\n            <slot></slot>\n          </div>\n\n          ${footerNode}\n        </section>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, attribute: 'hide-footer' })\n], Popover.prototype, \"hideFooter\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Popover.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'hide-arrow' })\n], Popover.prototype, \"hideArrow\", void 0);\n__decorate([\n    property({ type: String, attribute: 'header-text' })\n], Popover.prototype, \"headerText\", void 0);\n__decorate([\n    property({ type: String, attribute: 'horizontal-align' })\n], Popover.prototype, \"horizontalAlign\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'offset-x' })\n], Popover.prototype, \"offsetX\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateX\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateY\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"opened\", void 0);\n__decorate([\n    query('.stylospectrum-popover-wrapper')\n], Popover.prototype, \"popup\", void 0);\nPopover = Popover_1 = __decorate([\n    customElement('stylospectrum-popover')\n], Popover);\nexport default Popover;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { Placement } from '../types';\nlet Tooltip = class Tooltip extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    connectedCallback() {\n        super.connectedCallback();\n        setTimeout(() => {\n            const openerRect = JSON.parse(this.openerRect);\n            this.style.left =\n                openerRect.left + (openerRect.width - this.offsetWidth) / 2 + 'px';\n            if (this.placement === Placement.Top) {\n                this.style.top = openerRect.top - this.offsetHeight - 8 + 'px';\n            }\n            else {\n                this.style.top = openerRect.bottom + 8 + 'px';\n            }\n        });\n    }\n    render() {\n        return html `\n      <div class=\"stylospectrum-tooltip\">\n        <div class=\"stylospectrum-tooltip-text\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property({ type: String, reflect: false })\n], Tooltip.prototype, \"openerRect\", void 0);\n__decorate([\n    property({ type: String })\n], Tooltip.prototype, \"placement\", void 0);\nTooltip = __decorate([\n    customElement('stylospectrum-tooltip')\n], Tooltip);\nexport default Tooltip;\n"],"names":[],"sourceRoot":""}