{"version":3,"file":"295.87ad8627.iframe.bundle.js","mappings":";AAeA;AACA;AAKA;AAKA;;AAIA;;;AAIA;;;AAIA;;;AAIA;ACuFA;AACA;AA0PA;;AAGA;;;;AAQA;;AAIA;;AAIA;;AAEA;;;;;;AAMA;;AAGA","sources":["webpack://@stylospectrum/ui/./src/list/list-item.ts","webpack://@stylospectrum/ui/./src/popover/index.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { consume } from '@lit/context';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { listContext } from './context';\nimport styles from './style/list-item.scss';\nimport '../icon';\nlet ListItem = class ListItem extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    render() {\n        const selected = (this._consumer?.selectedId || this._consumer?.defaultSelectedId) ===\n            this.id;\n        return html `<li\n      class=${classMap({\n            'stylospectrum-list-item': true,\n            'stylospectrum-list-item-selected': selected,\n            'stylospectrum-list-item-focused': this.focused,\n        })}\n      @click=${() => {\n            this._consumer?.onChangeId?.(this.id);\n        }}\n    >\n      ${this.icon\n            ? html ` <span class=\"stylospectrum-list-item-icon-wrapper\">\n            <stylospectrum-icon\n              class=\"stylospectrum-list-item-icon\"\n              name=\"${this.icon}\"\n            >\n            </stylospectrum-icon>\n          </span>`\n            : nothing}\n\n      <span class=\"stylospectrum-list-item-text\"><slot></slot></span>\n    </li>`;\n    }\n};\n__decorate([\n    property({ type: String })\n], ListItem.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], ListItem.prototype, \"focused\", void 0);\n__decorate([\n    consume({ context: listContext, subscribe: true })\n], ListItem.prototype, \"_consumer\", void 0);\nListItem = __decorate([\n    customElement('stylospectrum-list-item')\n], ListItem);\nexport default ListItem;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Popover_1;\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property, state } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { Placement, PopoverHorizontalAlign } from '../types';\nimport clamp from '../utils/clamp';\nimport getParentElement from '../utils/getParentElement';\nimport isElementContainingBlock from '../utils/isElementContainingBlock';\nimport { getFocusedElement, isClickInRect } from '../utils/popup';\nimport { getFirstFocusableElement } from '../utils/focusableElements';\nimport { event } from '../utils';\nconst ARROW_SIZE = 8;\nconst openedRegistry = [];\nlet Popover = class Popover extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Determines on which side the component is placed at.\n         *\n         * @default \"Bottom\"\n         * @public\n         */\n        this.placement = Placement.Bottom;\n        /**\n         * Determines the horizontal alignment of the component.\n         *\n         * @type {PopoverHorizontalAlign}\n         * @defaultValue \"Center\"\n         * @public\n         */\n        this.horizontalAlign = PopoverHorizontalAlign.Center;\n        /**\n         * @type {number}\n         * @defaultValue 0\n         * @private\n         */\n        this.offsetX = 0;\n        /**\n         * @type {number}\n         * @defaultValue 0\n         * @private\n         */\n        this.offsetY = 0;\n        this.arrowTranslateX = 0;\n        this.arrowTranslateY = 0;\n        this.opened = false;\n        this._clickHandler = (event) => {\n            const openedPopups = [...openedRegistry];\n            if (openedPopups.length === 0) {\n                return;\n            }\n            const isTopPopupPopover = openedPopups[openedPopups.length - 1].instance instanceof Popover_1;\n            if (!isTopPopupPopover) {\n                return;\n            }\n            for (let i = openedPopups.length - 1; i !== -1; i--) {\n                const popup = openedPopups[i].instance;\n                if (popup._isOpenerClicked(event)) {\n                    return;\n                }\n                if (isClickInRect(event, popup.getBoundingClientRect())) {\n                    break;\n                }\n                popup.hide();\n            }\n        };\n        this._attachGlobalClickHandler = () => {\n            document.addEventListener('mousedown', this._clickHandler);\n        };\n        this._detachGlobalClickHandler = () => {\n            document.removeEventListener('mousedown', this._clickHandler);\n        };\n        this._getParentPopoversIfNested = (instance) => {\n            let currentElement = instance.parentNode;\n            const parentPopovers = [];\n            while (currentElement && currentElement.parentNode) {\n                for (let i = 0; i < openedRegistry.length; i++) {\n                    if (currentElement === openedRegistry[i].instance) {\n                        parentPopovers.push(currentElement);\n                    }\n                }\n                currentElement = currentElement.parentNode;\n            }\n            return parentPopovers;\n        };\n        this._addOpenedPopover = (instance) => {\n            const parentPopovers = this._getParentPopoversIfNested(instance);\n            openedRegistry.push({\n                instance,\n                parentPopovers,\n            });\n            if (openedRegistry.length === 1) {\n                this._attachGlobalClickHandler();\n            }\n        };\n        this._removeOpenedPopover = (instance) => {\n            const popoversToClose = [instance];\n            for (let i = 0; i < openedRegistry.length; i++) {\n                const indexOfCurrentInstance = openedRegistry[i].parentPopovers.indexOf(instance);\n                if (openedRegistry[i].parentPopovers.length > 0 &&\n                    indexOfCurrentInstance > -1) {\n                    popoversToClose.push(openedRegistry[i].instance);\n                }\n            }\n            for (let i = popoversToClose.length - 1; i >= 0; i--) {\n                for (let j = 0; j < openedRegistry.length; j++) {\n                    let indexOfItemToRemove = -1;\n                    if (popoversToClose[i] === openedRegistry[j].instance) {\n                        indexOfItemToRemove = j;\n                    }\n                    if (indexOfItemToRemove >= 0) {\n                        const itemToClose = openedRegistry.splice(indexOfItemToRemove, 1);\n                        itemToClose[0].instance.hide();\n                    }\n                }\n            }\n            if (!openedRegistry.length) {\n                this._detachGlobalClickHandler();\n            }\n        };\n    }\n    static { Popover_1 = this; }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    static get VIEWPORT_MARGIN() {\n        return 10; // px\n    }\n    _isOpenerClicked(e) {\n        const target = e.target;\n        if (target === this._opener) {\n            return true;\n        }\n        return e.composedPath().indexOf(this._opener) > -1;\n    }\n    _getContainingBlockClient() {\n        let parentElement = getParentElement(this);\n        while (parentElement) {\n            if (isElementContainingBlock(parentElement)) {\n                return parentElement;\n            }\n            parentElement = getParentElement(parentElement);\n        }\n        return null;\n    }\n    _getPopupSize() {\n        const rect = this.getBoundingClientRect(), width = rect.width, height = rect.height;\n        return { width, height };\n    }\n    _getVerticalLeft(targetRect, popoverSize) {\n        let left = 0;\n        switch (this.horizontalAlign) {\n            case PopoverHorizontalAlign.Left:\n                left = targetRect.left;\n                break;\n            case PopoverHorizontalAlign.Center:\n                left = targetRect.left - (popoverSize.width - targetRect.width) / 2;\n                break;\n            case PopoverHorizontalAlign.Right:\n                left = targetRect.right - popoverSize.width + this.offsetX;\n                break;\n        }\n        return left;\n    }\n    _getHorizontalTop(targetRect, popoverSize) {\n        return targetRect.top - (popoverSize.height - targetRect.height) / 2;\n    }\n    _getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius) {\n        let arrowXCentered = this.horizontalAlign === PopoverHorizontalAlign.Center;\n        if (this.horizontalAlign === PopoverHorizontalAlign.Right &&\n            left <= targetRect.left) {\n            arrowXCentered = true;\n        }\n        let arrowTranslateX = 0;\n        if (isVertical && arrowXCentered) {\n            arrowTranslateX =\n                targetRect.left + targetRect.width / 2 - left - popoverSize.width / 2;\n        }\n        let arrowTranslateY = 0;\n        const safeRangeForArrowY = popoverSize.height / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateY = clamp(arrowTranslateY, -safeRangeForArrowY, safeRangeForArrowY);\n        const safeRangeForArrowX = popoverSize.width / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateX = clamp(arrowTranslateX, -safeRangeForArrowX, safeRangeForArrowX);\n        return {\n            x: Math.round(arrowTranslateX),\n            y: Math.round(arrowTranslateY),\n        };\n    }\n    /**\n     * Fallbacks to new placement, prioritizing <code>Left</code> and <code>Right</code> placements.\n     * @private\n     */\n    _fallbackPlacement(clientWidth, clientHeight, targetRect, popoverSize) {\n        if (targetRect.left > popoverSize.width) {\n            return Placement.Left;\n        }\n        if (clientWidth - targetRect.right > targetRect.left) {\n            return Placement.Right;\n        }\n        if (clientHeight - targetRect.bottom > popoverSize.height) {\n            return Placement.Bottom;\n        }\n        if (clientHeight - targetRect.bottom < targetRect.top) {\n            return Placement.Top;\n        }\n        return undefined;\n    }\n    _getScale() {\n        if (!this._scaleElement) {\n            this._scaleElement = this._getContainingBlockClient();\n        }\n        if (this._scaleElement) {\n            const { transform } = window.getComputedStyle(this._scaleElement);\n            if (transform && transform !== 'none') {\n                const matrix = transform.match(/^matrix\\((.+)\\)$/);\n                if (matrix) {\n                    const matrixValues = matrix[1].split(', ');\n                    const scaleX = parseFloat(matrixValues[0]);\n                    const scaleY = parseFloat(matrixValues[3]);\n                    return { scaleX, scaleY };\n                }\n            }\n            return { scaleX: 1, scaleY: 1 };\n        }\n        return { scaleX: 1, scaleY: 1 };\n    }\n    _getActualPlacement(targetRect, popoverSize) {\n        let actualPlacement = this.placement;\n        const scale = this._getScale();\n        const clientWidth = document.documentElement.clientWidth / scale.scaleX;\n        const clientHeight = document.documentElement.clientHeight / scale.scaleY;\n        switch (this.placement) {\n            case Placement.Bottom:\n                if (clientHeight - targetRect.bottom < popoverSize.height &&\n                    clientHeight - targetRect.bottom < targetRect.top) {\n                    actualPlacement = Placement.Top;\n                }\n                break;\n            case Placement.Left:\n                if (targetRect.left < popoverSize.width) {\n                    actualPlacement =\n                        this._fallbackPlacement(clientWidth, clientHeight, targetRect, popoverSize) || this.placement;\n                }\n                break;\n        }\n        return actualPlacement;\n    }\n    _calcPlacement(targetRect, popoverSize) {\n        let left = 0;\n        let top = 0;\n        const scale = this._getScale();\n        targetRect = {\n            ...targetRect,\n            width: targetRect.width / scale.scaleX,\n            height: targetRect.height / scale.scaleY,\n            left: targetRect.left / scale.scaleX,\n            right: targetRect.right / scale.scaleX,\n            top: targetRect.top / scale.scaleY,\n            bottom: targetRect.bottom / scale.scaleY,\n        };\n        popoverSize = {\n            width: popoverSize.width / scale.scaleX,\n            height: popoverSize.height / scale.scaleY,\n        };\n        const clientWidth = document.documentElement.clientWidth / scale.scaleX;\n        const isVertical = this.placement === Placement.Bottom;\n        const arrowOffset = this.hideArrow ? 0 : ARROW_SIZE;\n        const placement = this._getActualPlacement(targetRect, popoverSize);\n        switch (placement) {\n            case Placement.Bottom:\n                left = this._getVerticalLeft(targetRect, popoverSize);\n                top = targetRect.bottom + arrowOffset + this.offsetY;\n                break;\n            case Placement.Left:\n                left = Math.max(targetRect.left - popoverSize.width - arrowOffset, 0);\n                top = this._getHorizontalTop(targetRect, popoverSize);\n                break;\n            case Placement.Right:\n                left = targetRect.left + targetRect.width + arrowOffset + this.offsetX;\n                top = this._getHorizontalTop(targetRect, popoverSize);\n                break;\n        }\n        if (isVertical) {\n            if (popoverSize.width > clientWidth || left < 0) {\n                left = 0;\n            }\n            else if (left + popoverSize.width > clientWidth) {\n                left -= left + popoverSize.width - clientWidth;\n            }\n        }\n        if (this._left === undefined || Math.abs(this._left - left) > 1.5) {\n            this._left = Math.round(left);\n        }\n        if (this._top === undefined || Math.abs(this._top - top) > 1.5) {\n            this._top = Math.round(top);\n        }\n        const borderRadius = Number.parseInt(window.getComputedStyle(this).getPropertyValue('border-radius'));\n        const arrowPos = this._getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius);\n        return {\n            arrow: arrowPos,\n            top: this._top,\n            left: this._left,\n        };\n    }\n    _resetFocus() {\n        if (!this._focusedElementBeforeOpen) {\n            return;\n        }\n        this._focusedElementBeforeOpen.focus();\n        this._focusedElementBeforeOpen = null;\n    }\n    showAt(opener, width) {\n        this._opener = opener;\n        this.show(width);\n    }\n    show(width) {\n        if (this.opened) {\n            return;\n        }\n        if (width) {\n            this.style.width = `${width}px`;\n        }\n        this.style.display = 'block';\n        this.openEvent.emit();\n        const popupSize = this._getPopupSize();\n        const openerRect = this._opener.getBoundingClientRect();\n        if (popupSize.width === 0 || popupSize.height === 0) {\n            return;\n        }\n        const placement = this._calcPlacement(openerRect, popupSize);\n        const scale = this._getScale();\n        const doc = document.documentElement;\n        const maxWidth = (doc.clientWidth - popupSize.width - Popover_1.VIEWPORT_MARGIN) /\n            scale.scaleX;\n        const maxHeight = (doc.clientHeight - popupSize.height - Popover_1.VIEWPORT_MARGIN) /\n            scale.scaleY;\n        let left = clamp(this._left, Popover_1.VIEWPORT_MARGIN, maxWidth);\n        let top = clamp(this._top, Popover_1.VIEWPORT_MARGIN, maxHeight);\n        top = Math.max(top, this._top);\n        this.arrowTranslateX = placement.arrow.x;\n        this.arrowTranslateY = placement.arrow.y;\n        const containingBlockClient = this._getContainingBlockClient();\n        const containingBlockClientLocation = containingBlockClient?.getBoundingClientRect();\n        if (containingBlockClientLocation) {\n            left -= containingBlockClientLocation.left / scale.scaleX;\n            top -= containingBlockClientLocation.top / scale.scaleY;\n        }\n        this._addOpenedPopover(this);\n        this.opened = true;\n        this._focusedElementBeforeOpen = getFocusedElement();\n        const ele = getFirstFocusableElement(this);\n        ele?.focus();\n        Object.assign(this.style, {\n            top: `${top}px`,\n            left: `${left}px`,\n        });\n    }\n    hide() {\n        if (!this.opened) {\n            return;\n        }\n        this._removeOpenedPopover(this);\n        this.opened = false;\n        this._resetFocus();\n        this.style.display = 'none';\n        Object.assign(this.style, {\n            top: '-10000px',\n            left: '-10000px',\n        });\n        this.closeEvent.emit();\n    }\n    render() {\n        const headerNode = this.headerText\n            ? html `<header class=\"stylospectrum-popover-header\" part=\"header\">\n          <h1 class=\"stylospectrum-popover-header-text\">${this.headerText}</h1>\n          <slot name=\"sub-header\"></slot>\n        </header>`\n            : nothing;\n        const footerNode = this.hideFooter\n            ? nothing\n            : html `<footer part=\"footer\" class=\"stylospectrum-popover-footer\">\n          <div class=\"stylospectrum-popover-footer-space\"></div>\n          <slot name=\"ok-button\"></slot>\n          <slot name=\"cancel-button\"></slot>\n        </footer>`;\n        const arrowNode = this.hideArrow\n            ? nothing\n            : html `<span\n          class=\"stylospectrum-popover-arrow\"\n          style=\"transform:translate(${this.arrowTranslateX}px, ${this\n                .arrowTranslateY}px)\"\n        >\n        </span>`;\n        return html `\n      <section class=\"stylospectrum-popover\">\n        ${arrowNode} ${headerNode}\n\n        <div part=\"content\" class=\"stylospectrum-popover-content\">\n          <slot></slot>\n        </div>\n\n        ${footerNode}\n      </section>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, attribute: 'hide-footer' })\n], Popover.prototype, \"hideFooter\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Popover.prototype, \"placement\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'hide-arrow' })\n], Popover.prototype, \"hideArrow\", void 0);\n__decorate([\n    property({ type: String, attribute: 'header-text' })\n], Popover.prototype, \"headerText\", void 0);\n__decorate([\n    property({ type: String, attribute: 'horizontal-align' })\n], Popover.prototype, \"horizontalAlign\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'offset-x' })\n], Popover.prototype, \"offsetX\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'offset-y' })\n], Popover.prototype, \"offsetY\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateX\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateY\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"opened\", void 0);\n__decorate([\n    event({ name: 'close' })\n], Popover.prototype, \"closeEvent\", void 0);\n__decorate([\n    event({ name: 'open' })\n], Popover.prototype, \"openEvent\", void 0);\nPopover = Popover_1 = __decorate([\n    customElement('stylospectrum-popover')\n], Popover);\nexport default Popover;\n"],"names":[],"sourceRoot":""}