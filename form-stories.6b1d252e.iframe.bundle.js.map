{"version":3,"file":"form-stories.6b1d252e.iframe.bundle.js","mappings":";AAgCA;AACA;AAMA;AACA;;AAEA;AANA;;AA+BA;AACA;;AAGA;;AAMA;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AClEA;AACA;;;;AA6CA;AAGA;AAEA;;;;;AAMA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;;;;;AAMA;;AAGA;;;;ACfA;AC7DA;AACA;AA4GA;AACA;;;AAIA;;AAGA;;AAEA;AACA;AACA;AACA;;;;AAKA;ACpIA;;;;AAIA;;;;AAUA;;;;;;;AAaA;;;AAGA;;AAEA;;;;;;AAUA;;;;;;;;;;;;;AAaA;AACA;;;;;AASA;;;AAGA;;AAMA;AACA;;;;;;AAoBA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAEA;;;;AAIA;;;;;;AAMA;;;;;;;AAWA;;;;;AAKA;;;;;;AAMA;;;;;;AAeA;;;;AAIA;AClLA;AACA;AAcA;;;;;;;AAOA;;;;AAKA;AC9BA;AACA;;;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;ACjBA;AACA;;AAuBA;;AAEA;AACA;;;AAGA;;AAGA;;;;AAIA;;;;;;AAQA;AC3CA;AACA;;;;;;;AAqDA;;AAGA;AAGA;AAEA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAGA;AC5GA;AACA;;;;;;AAuBA","sources":["webpack://@stylospectrum/ui/./src/button/index.ts","webpack://@stylospectrum/ui/./src/checkbox/index.ts","webpack://@stylospectrum/ui/./src/form/index.ts","webpack://@stylospectrum/ui/./src/form/form-item.ts","webpack://@stylospectrum/ui/./src/form/stories.ts","webpack://@stylospectrum/ui/./src/label/index.ts","webpack://@stylospectrum/ui/./src/link/index.ts","webpack://@stylospectrum/ui/./src/multi-input/index.ts","webpack://@stylospectrum/ui/./src/textarea/index.ts","webpack://@stylospectrum/ui/./src/tooltip/index.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, render } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ButtonDesign, ButtonType } from '../types';\nimport styles from './style/index.scss';\nimport '../icon';\nimport '../tooltip';\nlet Button = class Button extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {ButtonDesign}\n         * @defaultValue \"Primary\"\n         * @public\n         */\n        this.type = ButtonDesign.Primary;\n        /**\n         * Defines whether the button has special form-related functionality.\n         *\n         * @type {ButtonType}\n         * @defaultValue \"Button\"\n         * @public\n         */\n        this.htmlType = ButtonType.Button;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    tooltipTemplate(hovered = false) {\n        if (!hovered) {\n            return nothing;\n        }\n        return html `<stylospectrum-tooltip\n      openerRect=${JSON.stringify(this.getBoundingClientRect())}\n      placement=${this.tooltipPlacement}\n    >\n      ${this.tooltip}\n    </stylospectrum-tooltip>`;\n    }\n    handleFocusIn() {\n        this.focused = true;\n    }\n    handleFocusOut() {\n        this.focused = false;\n    }\n    handleMouseEnter() {\n        if (!this.tooltip) {\n            return;\n        }\n        render(this.tooltipTemplate(true), document.body);\n    }\n    handleMouseLeave() {\n        if (!this.tooltip) {\n            return;\n        }\n        render(this.tooltipTemplate(), document.body);\n    }\n    render() {\n        const iconNode = this.icon\n            ? html `<stylospectrum-icon\n          class=\"stylospectrum-button-icon\"\n          name=${this.icon}\n          rotate=${this.iconRotate}\n        >\n        </stylospectrum-icon>`\n            : html `<slot name=\"icon\"></slot>`;\n        const textNode = this.icon\n            ? nothing\n            : html `<span class=\"stylospectrum-button-text\">\n          <slot></slot>\n        </span>`;\n        const classes = {\n            'stylospectrum-button': true,\n            'stylospectrum-button-has-icon': !!this.icon,\n        };\n        return html `\n      <button\n        ?disabled=${this.disabled}\n        type=${this.htmlType.toLowerCase()}\n        part=\"button\"\n        class=${classMap(classes)}\n        @focusout=${this.handleFocusOut}\n        @focusin=${this.handleFocusIn}\n        @mouseenter=${this.handleMouseEnter}\n        @mouseleave=${this.handleMouseLeave}\n      >\n        ${textNode} ${iconNode}\n      </button>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"icon\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"iconRotate\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"tooltip\", void 0);\n__decorate([\n    property({ type: String, attribute: 'tooltip-placement' })\n], Button.prototype, \"tooltipPlacement\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Button.prototype, \"type\", void 0);\n__decorate([\n    property({ type: String, attribute: 'html-type', reflect: true })\n], Button.prototype, \"htmlType\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"focused\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"circle\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true, attribute: 'tab-selected' })\n], Button.prototype, \"tabSelected\", void 0);\nButton = __decorate([\n    customElement('stylospectrum-button')\n], Button);\nexport default Button;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property, query, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport styles from './style/index.scss';\nimport { event } from '../utils';\nimport { isEnter, isSpace } from '../utils/Keys';\nimport '../icon';\nimport '../tooltip';\nimport '../icon/data/accept';\nlet Checkbox = class Checkbox extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines the inner stored value of the component.\n         *\n         * @type {string}\n         * @defaultValue \"\"\n         * @private\n         */\n        this._innerChecked = false;\n        this._controlled = false;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    get effectiveTabIndex() {\n        const tabindex = this.getAttribute('tabindex');\n        return this.disabled ? undefined : tabindex || '0';\n    }\n    _handleKeyDown(e) {\n        if (isSpace(e)) {\n            e.preventDefault();\n        }\n        if (isEnter(e)) {\n            this.toggle(true);\n        }\n    }\n    _handleKeyUp(e) {\n        if (isSpace(e)) {\n            this.toggle(true);\n        }\n    }\n    toggle(_key = false) {\n        if (_key) {\n            this.inputEle.checked = !this.inputEle.checked;\n        }\n        const checked = this.inputEle.checked;\n        if (this.disabled || this.indeterminate) {\n            return;\n        }\n        if (!this._controlled) {\n            this._innerChecked = checked;\n        }\n        this.changeEvent.emit(checked);\n    }\n    willUpdate(_changedProperties) {\n        super.willUpdate(_changedProperties);\n        if (_changedProperties.has('checked') && !this.indeterminate) {\n            this._controlled = true;\n            this._innerChecked = this.checked;\n        }\n    }\n    render() {\n        const checkNode = this._innerChecked && !this.indeterminate\n            ? html `<stylospectrum-icon\n            class=\"stylospectrum-checkbox-icon\"\n            name=\"accept\"\n          >\n          </stylospectrum-icon>`\n            : nothing;\n        const textNode = this.text\n            ? html `<stylospectrum-label class=\"stylospectrum-checkbox-label\">\n          ${this.text}\n        </stylospectrum-label>`\n            : nothing;\n        return html `\n      <label\n        class=\"stylospectrum-checkbox-wrapper\"\n        role=\"checkbox\"\n        part=\"root\"\n        tabindex=\"${ifDefined(this.effectiveTabIndex)}\"\n        @keydown=\"${this._handleKeyDown}\"\n        @keyup=\"${this._handleKeyUp}\"\n      >\n        <span class=\"stylospectrum-checkbox-inner\">\n          ${checkNode}\n          <input\n            @input=${() => this.toggle()}\n            type=\"checkbox\"\n            ?checked=\"${this._innerChecked}\"\n            ?disabled=\"${this.disabled}\"\n            tabindex=\"-1\"\n            aria-hidden=\"true\"\n          />\n        </span>\n\n        ${textNode}\n      </label>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"checked\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"text\", void 0);\n__decorate([\n    state()\n], Checkbox.prototype, \"_innerChecked\", void 0);\n__decorate([\n    state()\n], Checkbox.prototype, \"_controlled\", void 0);\n__decorate([\n    event({ name: 'change' })\n], Checkbox.prototype, \"changeEvent\", void 0);\n__decorate([\n    query('input')\n], Checkbox.prototype, \"inputEle\", void 0);\nCheckbox = __decorate([\n    customElement('stylospectrum-checkbox')\n], Checkbox);\nexport default Checkbox;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { ContextProvider } from '@lit/context';\nimport { LitElement, html } from 'lit';\nimport { customElement, property, state } from 'lit/decorators.js';\nimport { ValueState } from '../types';\nimport Input from '../input';\nimport { formContext } from './context';\nimport { cloneByNamePathList, setValue } from './utils';\nlet Form = class Form extends LitElement {\n    constructor() {\n        super(...arguments);\n        this._provider = new ContextProvider(this, { context: formContext });\n        this._formItems = [];\n        this.list = {};\n        this.store = {};\n    }\n    getFieldsValue() {\n        return cloneByNamePathList(this.store, this._formItems.map((el) => el.getNamePath()));\n    }\n    setFieldsValue(store) {\n        const formItems = Object.fromEntries(this._formItems.map((el) => [el.getFieldId(), el]));\n        const formList = Object.fromEntries(Object.values(this.list).map((el) => [el.name, el]));\n        Object.keys(store).forEach((key) => {\n            if (formItems?.[key]) {\n                formItems[key].value = store[key];\n                this.store = setValue(this.store, formItems[key].getNamePath(), store[key]);\n            }\n            if (formList[key]) {\n                formList[key].values = store[key];\n                this.store = setValue(this.store, [formList[key].name], store[key]);\n            }\n        });\n    }\n    resetFields() {\n        this.setFieldsValue(this.initialValues);\n        this._formItems.forEach((item) => {\n            const slot = item.shadowRoot?.querySelector('slot');\n            const node = slot?.assignedElements({ flatten: true })?.[0];\n            if (node instanceof Input) {\n                node.valueState = ValueState.None;\n                node.valueStateMessage = '';\n            }\n        });\n    }\n    async validateFields() {\n        let hasError = false;\n        try {\n            await Promise.all(this._formItems.map((el) => el.validateRules()));\n        }\n        catch (e) {\n            hasError = true;\n        }\n        if (!hasError) {\n            return this.getFieldsValue();\n        }\n        return null;\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        this.store = this.initialValues;\n        this._provider.setValue({\n            getStore: () => this.store,\n            setStore: (namePath, value) => {\n                this.store = setValue(this.store, namePath, value);\n            },\n            registerField: (formItem) => {\n                this._formItems.push(formItem);\n                return () => {\n                    this._formItems = this._formItems.filter((el) => el !== formItem);\n                    if (!formItem._formListConsumer) {\n                        setValue(this.store, formItem.getNamePath(), undefined, true);\n                    }\n                };\n            },\n            registerList: (name, entity) => {\n                this.list[name] = entity;\n            },\n        });\n    }\n    render() {\n        return html `\n      <form class=\"stylospectrum-form\">\n        <slot></slot>\n      </form>\n    `;\n    }\n};\n__decorate([\n    property({ attribute: 'initial-values', type: Object, reflect: false })\n], Form.prototype, \"initialValues\", void 0);\n__decorate([\n    state()\n], Form.prototype, \"store\", void 0);\nForm = __decorate([\n    customElement('stylospectrum-form')\n], Form);\nexport default Form;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, } from 'lit';\nimport { customElement, property, queryAssignedElements, } from 'lit/decorators.js';\nimport AsyncValidator from 'async-validator';\nimport Checkbox from '../checkbox';\nimport MultiInput from '../multi-input';\nimport styles from './style/form-item.scss';\nimport { ValueState } from '../types';\nimport { formContext, formListContext, } from './context';\nimport { consume } from '@lit/context';\nimport '../label';\nimport { getValue } from './utils';\nlet FormItem = class FormItem extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {Array<Rule>}\n         * @defaultValue []\n         * @public\n         */\n        this.rules = [];\n        this.cancelRegisterFunc = null;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    connectedCallback() {\n        super.connectedCallback();\n        this.value = getValue(this.getNamePath(), this._formConsumer.getStore());\n        requestAnimationFrame(() => {\n            if (!(this.slotEls[0] instanceof Checkbox) && this.value) {\n                this.slotEls[0].value = this.value;\n            }\n        });\n        if (this._formConsumer) {\n            this.cancelRegisterFunc = this._formConsumer.registerField(this);\n        }\n    }\n    disconnectedCallback() {\n        super.disconnectedCallback();\n        this.cancelRegisterFunc?.();\n    }\n    getNamePath() {\n        const namePath = Array.isArray(this.name) ? this.name : [this.name];\n        return this._formListConsumer\n            ? [this._formListConsumer.listName, ...namePath]\n            : namePath;\n    }\n    getFieldId() {\n        return this.getNamePath().join('_');\n    }\n    _handleChange(e) {\n        if (!(e.target instanceof MultiInput)) {\n            this.value = e.detail;\n            this._formConsumer.setStore(this.getNamePath(), this.value);\n            this.validateRules();\n        }\n    }\n    _handleEnter(e) {\n        if (e.target instanceof MultiInput) {\n            this.value = [...(this.value || []), e.detail];\n            this._formConsumer.setStore(this.getNamePath(), this.value);\n            this.validateRules();\n        }\n    }\n    _handleTokenDelete(e) {\n        this.value = this.value.filter((item) => item.id !== e.detail);\n        this._formConsumer.setStore(this.getNamePath(), this.value);\n    }\n    _handleSlotChange() {\n        const formControl = this.slotEls?.[0];\n        if (formControl) {\n            formControl.id = this.getFieldId();\n        }\n    }\n    async _validateRule(rule) {\n        const validator = new AsyncValidator({\n            [this.getFieldId()]: [rule],\n        });\n        let result = [];\n        try {\n            await Promise.resolve(validator.validate({ [this.getFieldId()]: this.value }));\n        }\n        catch (errObj) {\n            if (errObj.errors) {\n                result = errObj.errors.map(({ message }) => {\n                    return message;\n                });\n            }\n        }\n        return result;\n    }\n    validateRules() {\n        // eslint-disable-next-line no-async-promise-executor\n        const promise = new Promise(async (resolve, reject) => {\n            for (let i = 0; i < this.rules.length; i++) {\n                const errors = await this._validateRule(this.rules[i]);\n                if (errors.length) {\n                    reject(errors);\n                    break;\n                }\n            }\n            resolve([]);\n        });\n        promise\n            .catch((e) => e)\n            .then((ruleErrors) => {\n            if (!(this.slotEls[0] instanceof Checkbox)) {\n                const input = this.slotEls[0];\n                if (ruleErrors.length > 0) {\n                    input.valueState = ValueState.Error;\n                    input.valueStateMessage = ruleErrors[0];\n                }\n                else {\n                    input.valueState = ValueState.None;\n                }\n            }\n        });\n        return promise;\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('value')) {\n            if (this.slotEls[0] instanceof Checkbox) {\n                this.slotEls[0].checked = this.value;\n            }\n            else {\n                this.slotEls[0].value = this.value;\n            }\n        }\n    }\n    render() {\n        const labelNode = this.label\n            ? html `<div class=\"stylospectrum-form-item-label-wrapper\">\n          <stylospectrum-label show-colon for=\"${this.name}\">\n            ${this.label}\n          </stylospectrum-label>\n          <slot name=\"suffix-label\"></slot>\n        </div>`\n            : nothing;\n        return html `\n      <div class=\"stylospectrum-form-item\">\n        ${labelNode}\n        <slot\n          @slotchange=${this._handleSlotChange}\n          @change=\"${this._handleChange}\"\n          @enter=${this._handleEnter}\n          @token-delete=${this._handleTokenDelete}\n        >\n        </slot>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property()\n], FormItem.prototype, \"name\", void 0);\n__decorate([\n    property()\n], FormItem.prototype, \"label\", void 0);\n__decorate([\n    property()\n], FormItem.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Array, reflect: false })\n], FormItem.prototype, \"rules\", void 0);\n__decorate([\n    queryAssignedElements({ flatten: true })\n], FormItem.prototype, \"slotEls\", void 0);\n__decorate([\n    consume({ context: formContext, subscribe: true })\n], FormItem.prototype, \"_formConsumer\", void 0);\n__decorate([\n    consume({ context: formListContext, subscribe: true })\n], FormItem.prototype, \"_formListConsumer\", void 0);\nFormItem = __decorate([\n    customElement('stylospectrum-form-item')\n], FormItem);\nexport default FormItem;\n","import { html } from 'lit';\nimport { createRef, ref } from 'lit/directives/ref.js';\nimport { isTabNext } from '../utils/Keys';\nimport '.';\nimport './form-item';\nimport './form-list';\nimport '../input';\nimport '../checkbox';\nimport '../button';\nimport '../link';\nimport '../multi-input';\nimport '../textarea';\nimport '../icon/data/less';\nexport default {\n    title: 'Form',\n    component: 'stylospectrum-form',\n    tags: ['autodocs'],\n};\nexport const LoginForm = () => {\n    const formRef = createRef();\n    const passwordRef = createRef();\n    const forgotPassRef = createRef();\n    const createAnAccRef = createRef();\n    return html `\n    <stylospectrum-form ${ref(formRef)} style=\"width: 27.75rem; display:block\">\n      <stylospectrum-form-item\n        label=\"Email\"\n        name=\"email\"\n        .rules=\"${[\n        { required: true, message: 'Enter your email' },\n        {\n            pattern: /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/,\n            message: 'Wrong or Invalid email address. Please correct and try again',\n        },\n    ]}\"\n      >\n        <stylospectrum-input\n          style=\"width: 100%\"\n          @keydown=\"${(e) => {\n        if (isTabNext(e)) {\n            requestAnimationFrame(() => {\n                passwordRef.value?.shadowRoot?.querySelector('input')?.focus();\n            });\n        }\n    }}\"\n        ></stylospectrum-input>\n      </stylospectrum-form-item>\n\n      <stylospectrum-form-item\n        label=\"Password\"\n        name=\"password\"\n        .rules=\"${[{ required: true, message: 'Enter your password' }]}\"\n      >\n        <stylospectrum-link\n          ${ref(forgotPassRef)}\n          slot=\"suffix-label\"\n          @keydown=\"${() => {\n        requestAnimationFrame(() => {\n            createAnAccRef.value?.shadowRoot?.querySelector('a')?.focus();\n        });\n    }}\"\n        >\n          Forgot your password?\n        </stylospectrum-link>\n        <stylospectrum-input\n          style=\"width: 100%\"\n          ${ref(passwordRef)}\n          type=\"Password\"\n        >\n        </stylospectrum-input>\n      </stylospectrum-form-item>\n\n      <stylospectrum-form-item name=\"keep-me-signed-in\">\n        <stylospectrum-checkbox text=\"Keep me signed in\">\n        </stylospectrum-checkbox>\n      </stylospectrum-form-item>\n    </stylospectrum-form>\n\n    <stylospectrum-button\n      @click=${async () => console.log(await formRef.value?.validateFields())}\n      @keydown=\"${() => {\n        requestAnimationFrame(() => {\n            forgotPassRef.value?.shadowRoot?.querySelector('a')?.focus();\n        });\n    }}\"\n    >\n      Submit\n    </stylospectrum-button>\n    <br />\n    <stylospectrum-link ${ref(createAnAccRef)}>\n      Create an account!\n    </stylospectrum-link>\n  `;\n};\nexport const BotEntityForm = () => {\n    const formRef = createRef();\n    return html `\n    <stylospectrum-form\n      ${ref(formRef)}\n      .initialValues=${{\n        name: 'size',\n        options: [\n            {\n                id: '1',\n                name: 'XL',\n                synonyms: [{ id: '2', name: 'extra large' }],\n            },\n            {\n                id: '2',\n                name: 'L',\n                synonyms: [{ id: '2', name: 'large' }],\n            },\n        ],\n    }}\n      style=\"width: 27.75rem; display:block\"\n    >\n      <stylospectrum-form-item\n        label=\"Name\"\n        name=\"name\"\n        .rules=\"${[{ required: true, message: 'Enter your name' }]}\"\n      >\n        <stylospectrum-input></stylospectrum-input>\n      </stylospectrum-form-item>\n\n      <div style=\"display:flex;gap:.5rem\">\n        <div\n          style=\"color: #FFF;font-size: 0.875rem;text-align:center;width: 13.75rem;\"\n        >\n          Option\n        </div>\n\n        <div\n          style=\"color: #FFF;font-size: 0.875rem;text-align:center;width: 18.75rem;\"\n        >\n          Synonyms\n        </div>\n      </div>\n\n      <stylospectrum-form-list\n        name=\"options\"\n        .renderChild=${(name, value) => {\n        return html `<div style=\"display:flex;gap:.5rem\">\n            <stylospectrum-form-item .name=${[name, 'name']}>\n              <stylospectrum-input></stylospectrum-input>\n            </stylospectrum-form-item>\n\n            <stylospectrum-form-item .name=${[name, 'synonyms']}>\n              <stylospectrum-multi-input></stylospectrum-multi-input>\n            </stylospectrum-form-item>\n\n            <stylospectrum-button\n              icon=\"less\"\n              @click=${() => {\n            formRef.value?.list.options.delete(name);\n            console.log(value);\n        }}\n            ></stylospectrum-button>\n          </div> `;\n    }}\n      >\n      </stylospectrum-form-list>\n    </stylospectrum-form>\n\n    <stylospectrum-button @click=${() => formRef.value?.list.options.add()}>\n      Add\n    </stylospectrum-button>\n\n    <stylospectrum-button\n      @click=${async () => console.log(await formRef.value?.validateFields())}\n    >\n      Submit\n    </stylospectrum-button>\n\n    <stylospectrum-button\n      @click=${() => formRef.value?.setFieldsValue({\n        name: 'color',\n        options: [\n            {\n                id: '1',\n                name: 'blue',\n                synonyms: [],\n            },\n        ],\n    })}\n    >\n      set field values\n    </stylospectrum-button>\n\n    <stylospectrum-button\n      @click=${() => console.log(formRef.value?.resetFields())}\n    >\n      Reset field\n    </stylospectrum-button>\n  `;\n};\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nlet Label = class Label extends LitElement {\n    constructor() {\n        super(...arguments);\n        this._colonSymbol = ':';\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    _handleClick() {\n        if (!this.for) {\n            return;\n        }\n        const slotNode = this.getRootNode().querySelector('slot');\n        const assignedElements = slotNode.assignedElements({ flatten: true });\n        const inputNode = assignedElements?.[0]?.shadowRoot?.querySelector('input');\n        if (inputNode) {\n            inputNode.focus();\n        }\n    }\n    render() {\n        return html `\n      <label class=\"stylospectrum-label-wrapper\" @click=\"${this._handleClick}\">\n        <span class=\"stylospectrum-label-text\">\n          <slot></slot>\n        </span>\n        <span\n          aria-hidden=\"true\"\n          class=\"stylospectrum-label-required-colon\"\n          data-colon=\"${this._colonSymbol}\"\n        >\n        </span>\n      </label>\n    `;\n    }\n};\n__decorate([\n    property()\n], Label.prototype, \"for\", void 0);\n__decorate([\n    property({ type: Boolean, attribute: 'show-colon' })\n], Label.prototype, \"showColon\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Label.prototype, \"required\", void 0);\nLabel = __decorate([\n    customElement('stylospectrum-label')\n], Label);\nexport default Label;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport styles from './style/index.scss';\nlet Link = class Link extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    constructor() {\n        super();\n        this._dummyAnchor = document.createElement('a');\n    }\n    _isCrossOrigin() {\n        const loc = window.location;\n        this._dummyAnchor.href = this.href;\n        return !(this._dummyAnchor.hostname === loc.hostname &&\n            this._dummyAnchor.port === loc.port &&\n            this._dummyAnchor.protocol === loc.protocol);\n    }\n    willUpdate() {\n        const needsNoReferrer = this.target !== '_self' && this.href && this._isCrossOrigin();\n        this._rel = needsNoReferrer ? 'noreferrer noopener' : undefined;\n    }\n    _handleFocusIn() {\n        this.focused = true;\n    }\n    _handleFocusOut() {\n        this.focused = false;\n    }\n    _handleClick(e) {\n        if (!this.href) {\n            e.preventDefault();\n        }\n    }\n    render() {\n        return html `\n      <a\n        class=\"stylospectrum-link\"\n        href=${this.href || '#'}\n        target=${ifDefined(this.target)}\n        rel=${ifDefined(this._rel)}\n        tabindex=${this.disabled ? '-1' : '0'}\n        title=\"${ifDefined(this.title || undefined)}\"\n        ?disabled=${this.disabled}\n        @click=${this._handleClick}\n        @focusin=${this._handleFocusIn}\n        @focusout=${this._handleFocusOut}\n      >\n        <slot></slot>\n      </a>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean })\n], Link.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Link.prototype, \"href\", void 0);\n__decorate([\n    property()\n], Link.prototype, \"target\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Link.prototype, \"focused\", void 0);\n__decorate([\n    state()\n], Link.prototype, \"_rel\", void 0);\nLink = __decorate([\n    customElement('stylospectrum-link')\n], Link);\nexport default Link;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property, query, state } from 'lit/decorators.js';\nimport * as uuid from 'uuid';\nimport styles from './style/index.scss';\nimport { event } from '../utils';\nimport '../input';\nimport '../icon/data/decline';\nlet MultiInput = class MultiInput extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines the value of the component.\n         *\n         * @type {MultiInputOption[]}\n         * @defaultValue []\n         * @public\n         */\n        this.value = [];\n        /**\n         * @type {MultiInputOption[]}\n         * @defaultValue []\n         * @public\n         */\n        this.defaultValue = [];\n        /**\n         * Defines the inner stored value of the component.\n         *\n         * @type {string}\n         * @defaultValue \"\"\n         * @private\n         */\n        this._innerValue = [];\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    willUpdate(_changedProperties) {\n        super.willUpdate(_changedProperties);\n        if (_changedProperties.has('value')) {\n            this._innerValue =\n                this.value?.length > 0 ? this.value : this.defaultValue;\n        }\n    }\n    handleInputEnter(event) {\n        if (event.detail) {\n            const newValue = { name: event.detail, id: 'client-' + uuid.v4() };\n            this.enterEvent.emit(newValue);\n            this._input.clear();\n            this._innerValue = [...this._innerValue, newValue];\n        }\n    }\n    handleTokenDelete(id) {\n        this.tokenDeleteEvent.emit(id);\n        this._innerValue = this._innerValue.filter((option) => option.id !== id);\n    }\n    render() {\n        return html `\n      <stylospectrum-input\n        style=${this.style.cssText}\n        class=\"stylospectrum-multi-input\"\n        ?tokenizer-available=${this._innerValue.length > 0}\n        @enter=${this.handleInputEnter}\n      >\n        <div class=\"stylospectrum-tokenizer\" slot=\"tokenizer\" role=\"listbox\">\n          ${this._innerValue.map((option) => {\n            return html `\n              <div class=\"stylospectrum-token\">\n                <span class=\"stylospectrum-token-label\">${option.name}</span>\n                <stylospectrum-icon\n                  class=\"stylospectrum-token-icon\"\n                  name=\"decline\"\n                  @click=${() => this.handleTokenDelete(option.id)}\n                ></stylospectrum-icon>\n              </div>\n            `;\n        })}\n        </div>\n      </stylospectrum-input>\n    `;\n    }\n};\n__decorate([\n    property({ type: Array })\n], MultiInput.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Array })\n], MultiInput.prototype, \"defaultValue\", void 0);\n__decorate([\n    state()\n], MultiInput.prototype, \"_innerValue\", void 0);\n__decorate([\n    event({ name: 'token-delete' })\n], MultiInput.prototype, \"tokenDeleteEvent\", void 0);\n__decorate([\n    event({ name: 'enter' })\n], MultiInput.prototype, \"enterEvent\", void 0);\n__decorate([\n    query('stylospectrum-input')\n], MultiInput.prototype, \"_input\", void 0);\nMultiInput = __decorate([\n    customElement('stylospectrum-multi-input')\n], MultiInput);\nexport default MultiInput;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, } from 'lit';\nimport { customElement, property, query, state } from 'lit/decorators.js';\nimport { ValueState } from '../types';\nimport { event } from '../utils';\nimport styles from './style/index.scss';\nimport '../icon';\nimport '../icon/data/error';\nlet Textarea = class Textarea extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines a short hint intended to aid the user with data entry when the component has no value.\n         *\n         * @type {string}\n         * @defaultValue \"\"\n         * @public\n         */\n        this.placeholder = '';\n        /**\n         * Defines the value state of the component.\n         *\n         * @type {ValueState}\n         * @defaultValue \"None\"\n         * @public\n         */\n        this.valueState = ValueState.None;\n        /**\n         * Defines the inner stored value of the component.\n         *\n         * @type {string}\n         * @defaultValue \"\"\n         * @private\n         */\n        this._innerValue = '';\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    _handleInput(e) {\n        const value = e.target.value;\n        if (!this.value) {\n            this._innerValue = value;\n        }\n        this._mirrorText = this.tokenizeText(value);\n        this.changeEvent.emit(value);\n    }\n    _handleFocus() {\n        this.focused = true;\n    }\n    _handleBlur() {\n        this.focused = false;\n    }\n    getFocusDomRef() {\n        return this.textarea;\n    }\n    tokenizeText(value) {\n        const tokenizedText = value\n            .replace(/&/gm, '&amp;')\n            .replace(/\"/gm, '&quot;')\n            .replace(/'/gm, '&apos;')\n            .replace(/</gm, '&lt;')\n            .replace(/>/gm, '&gt;')\n            .split('\\n');\n        return this.mapTokenizedTextToObject(tokenizedText);\n    }\n    mapTokenizedTextToObject(tokenizedText) {\n        return tokenizedText.map((token, index) => {\n            return {\n                text: token,\n                last: index === tokenizedText.length - 1,\n            };\n        });\n    }\n    willUpdate(_changedProperties) {\n        super.willUpdate(_changedProperties);\n        if (_changedProperties.has('value')) {\n            this._innerValue = this.value || '';\n        }\n    }\n    render() {\n        const valueStateMessageNode = this.valueStateMessage &&\n            this.valueState === ValueState.Error &&\n            this.focused\n            ? html ` <div class=\"stylospectrum-textarea-value-state-message-wrapper\">\n            <stylospectrum-icon\n              class=\"stylospectrum-textarea-value-state-message-icon\"\n              name=\"error\"\n            >\n            </stylospectrum-icon>\n            <span class=\"stylospectrum-textarea-value-state-message\">\n              ${this.valueStateMessage}\n            </span>\n          </div>`\n            : nothing;\n        const growingNode = this.growing\n            ? html `<div class=\"stylospectrum-textarea-mirror\">\n          ${(this._mirrorText || []).map((token) => html `${token.text} <br />`)}\n        </div>`\n            : nothing;\n        return html `\n      <span class=\"stylospectrum-textarea-wrapper\">\n        ${growingNode}\n        <textarea\n          .value=${this._innerValue || this.defaultValue || ''}\n          @focus=${this._handleFocus}\n          @blur=${this._handleBlur}\n          @input=${this._handleInput}\n          .placeholder=${this.placeholder}\n          class=\"stylospectrum-textarea\"\n          ?disabled=${this.disabled}\n        ></textarea>\n        ${valueStateMessageNode}\n      </span>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean })\n], Textarea.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: String })\n], Textarea.prototype, \"placeholder\", void 0);\n__decorate([\n    property({ type: String })\n], Textarea.prototype, \"value\", void 0);\n__decorate([\n    property({ type: String, attribute: 'default-value' })\n], Textarea.prototype, \"defaultValue\", void 0);\n__decorate([\n    property({ type: String, attribute: 'value-state', reflect: true })\n], Textarea.prototype, \"valueState\", void 0);\n__decorate([\n    property({ type: String, attribute: 'value-state-message' })\n], Textarea.prototype, \"valueStateMessage\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Textarea.prototype, \"growing\", void 0);\n__decorate([\n    state()\n], Textarea.prototype, \"_innerValue\", void 0);\n__decorate([\n    state()\n], Textarea.prototype, \"_mirrorText\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Textarea.prototype, \"focused\", void 0);\n__decorate([\n    event({ name: 'change' })\n], Textarea.prototype, \"changeEvent\", void 0);\n__decorate([\n    query('textarea')\n], Textarea.prototype, \"textarea\", void 0);\nTextarea = __decorate([\n    customElement('stylospectrum-textarea')\n], Textarea);\nexport default Textarea;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { Placement } from '../types';\nlet Tooltip = class Tooltip extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    connectedCallback() {\n        super.connectedCallback();\n        setTimeout(() => {\n            const openerRect = JSON.parse(this.openerRect);\n            this.style.left =\n                openerRect.left + (openerRect.width - this.offsetWidth) / 2 + 'px';\n            if (this.placement === Placement.Top) {\n                this.style.top = openerRect.top - this.offsetHeight - 8 + 'px';\n            }\n            else {\n                this.style.top = openerRect.bottom + 8 + 'px';\n            }\n        });\n    }\n    render() {\n        return html `\n      <div class=\"stylospectrum-tooltip\">\n        <div class=\"stylospectrum-tooltip-text\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property({ type: String, reflect: false })\n], Tooltip.prototype, \"openerRect\", void 0);\n__decorate([\n    property({ type: String })\n], Tooltip.prototype, \"placement\", void 0);\nTooltip = __decorate([\n    customElement('stylospectrum-tooltip')\n], Tooltip);\nexport default Tooltip;\n"],"names":[],"sourceRoot":""}