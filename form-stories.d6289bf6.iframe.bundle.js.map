{"version":3,"file":"form-stories.d6289bf6.iframe.bundle.js","mappings":";AAgCA;AACA;AAMA;AACA;;AAEA;AANA;;AAyBA;;AAGA;;AAMA;;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AC5DA;AACA;;;;AA4CA;AAGA;AAEA;;;;;AAMA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;;;;;;AAMA;;AAGA;AChFA;AACA;AAuEA;AACA;;;AAIA;;AAGA;;AAEA;AACA;;;;AAKA;;;;ACtDA;AC3CA;;;;AAIA;;;;AAUA;;;;;;;AAWA;;;AAGA;;AAEA;;;;;;AAUA;;;;;;;;;;;;;AAaA;AACA;;;;;AASA;;;AAGA;ACpEA;AACA;;;AA+BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAKA;AC7CA;AACA;;;;;;AAuBA","sources":["webpack://@stylospectrum/ui/./src/button/index.ts","webpack://@stylospectrum/ui/./src/checkbox/index.ts","webpack://@stylospectrum/ui/./src/form/form-item.ts","webpack://@stylospectrum/ui/./src/form/index.ts","webpack://@stylospectrum/ui/./src/form/stories.ts","webpack://@stylospectrum/ui/./src/link/index.ts","webpack://@stylospectrum/ui/./src/tooltip/index.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, render } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ButtonDesign, ButtonType } from '../types';\nimport styles from './style/index.scss';\nimport '../icon';\nimport '../tooltip';\nlet Button = class Button extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {ButtonDesign}\n         * @defaultValue \"Primary\"\n         * @public\n         */\n        this.type = ButtonDesign.Primary;\n        /**\n         * Defines whether the button has special form-related functionality.\n         *\n         * @type {ButtonType}\n         * @defaultValue \"Button\"\n         * @public\n         */\n        this.htmlType = ButtonType.Button;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    tooltipTemplate(hovered = false) {\n        if (!this.tooltip || !hovered) {\n            return nothing;\n        }\n        return html `<stylospectrum-tooltip\n      openerRect=${JSON.stringify(this.getBoundingClientRect())}\n      placement=${this.tooltipPlacement}\n    >\n      ${this.tooltip}\n    </stylospectrum-tooltip>`;\n    }\n    handleFocusIn() {\n        this.focused = true;\n    }\n    handleFocusOut() {\n        this.focused = false;\n    }\n    handleMouseOver() {\n        render(this.tooltipTemplate(true), document.body);\n    }\n    handleMouseLeave() {\n        render(this.tooltipTemplate(), document.body);\n    }\n    render() {\n        const iconNode = this.icon\n            ? html `<stylospectrum-icon\n          class=\"stylospectrum-button-icon\"\n          name=${this.icon}\n        >\n        </stylospectrum-icon>`\n            : html `<slot name=\"icon\"></slot>`;\n        const textNode = this.icon\n            ? nothing\n            : html `<span class=\"stylospectrum-button-text\">\n          <slot></slot>\n        </span>`;\n        const classes = {\n            'stylospectrum-button': true,\n            'stylospectrum-button-has-icon': !!this.icon,\n        };\n        return html `\n      <button\n        ?disabled=${this.disabled}\n        type=${this.htmlType.toLowerCase()}\n        part=\"button\"\n        class=${classMap(classes)}\n        @focusout=${this.handleFocusOut}\n        @focusin=${this.handleFocusIn}\n        @mouseover=${this.handleMouseOver}\n        @mouseleave=${this.handleMouseLeave}\n      >\n        ${textNode} ${iconNode}\n      </button>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"icon\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"tooltip\", void 0);\n__decorate([\n    property({ type: String })\n], Button.prototype, \"tooltipPlacement\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Button.prototype, \"type\", void 0);\n__decorate([\n    property({ type: String, attribute: 'html-type', reflect: true })\n], Button.prototype, \"htmlType\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"focused\", void 0);\nButton = __decorate([\n    customElement('stylospectrum-button')\n], Button);\nexport default Button;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property, query, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport styles from './style/index.scss';\nimport { event } from '../utils';\nimport { isEnter, isSpace } from '../utils/Keys';\nimport '../icon';\nimport '../tooltip';\nimport '../icon/data/accept';\nlet Checkbox = class Checkbox extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Defines the inner stored value of the component.\n         *\n         * @type {string}\n         * @defaultValue \"\"\n         * @private\n         */\n        this._innerChecked = false;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    get effectiveTabIndex() {\n        const tabindex = this.getAttribute('tabindex');\n        return this.disabled ? undefined : tabindex || '0';\n    }\n    _handleKeyDown(e) {\n        if (isSpace(e)) {\n            e.preventDefault();\n        }\n        if (isEnter(e)) {\n            this.toggle(true);\n        }\n    }\n    _handleKeyUp(e) {\n        if (isSpace(e)) {\n            this.toggle(true);\n        }\n    }\n    toggle(_key = false) {\n        if (_key) {\n            this.inputEle.checked = !this.inputEle.checked;\n        }\n        const checked = this.inputEle.checked;\n        if (this.disabled || this.indeterminate) {\n            return;\n        }\n        if (!this.checked) {\n            this._innerChecked = checked;\n        }\n        this.changeEvent.emit(checked);\n    }\n    willUpdate(_changedProperties) {\n        super.willUpdate(_changedProperties);\n        if (_changedProperties.has('checked') && !this.indeterminate) {\n            this._innerChecked = this.checked;\n        }\n    }\n    render() {\n        const checkNode = this._innerChecked && !this.indeterminate\n            ? html `<stylospectrum-icon\n            class=\"stylospectrum-checkbox-icon\"\n            name=\"accept\"\n          >\n          </stylospectrum-icon>`\n            : nothing;\n        const textNode = this.text\n            ? html `<stylospectrum-label class=\"stylospectrum-checkbox-label\">\n          ${this.text}\n        </stylospectrum-label>`\n            : nothing;\n        return html `\n      <label\n        class=\"stylospectrum-checkbox-wrapper\"\n        role=\"checkbox\"\n        part=\"root\"\n        tabindex=\"${ifDefined(this.effectiveTabIndex)}\"\n        @keydown=\"${this._handleKeyDown}\"\n        @keyup=\"${this._handleKeyUp}\"\n      >\n        <span class=\"stylospectrum-checkbox-inner\">\n          ${checkNode}\n          <input\n            @input=${() => this.toggle()}\n            type=\"checkbox\"\n            ?checked=\"${this._innerChecked}\"\n            ?disabled=\"${this.disabled}\"\n            tabindex=\"-1\"\n            aria-hidden=\"true\"\n          />\n        </span>\n\n        ${textNode}\n      </label>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"disabled\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"indeterminate\", void 0);\n__decorate([\n    property({ type: Boolean })\n], Checkbox.prototype, \"checked\", void 0);\n__decorate([\n    property()\n], Checkbox.prototype, \"text\", void 0);\n__decorate([\n    state()\n], Checkbox.prototype, \"_innerChecked\", void 0);\n__decorate([\n    event({ name: 'change' })\n], Checkbox.prototype, \"changeEvent\", void 0);\n__decorate([\n    query('input')\n], Checkbox.prototype, \"inputEle\", void 0);\nCheckbox = __decorate([\n    customElement('stylospectrum-checkbox')\n], Checkbox);\nexport default Checkbox;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing, } from 'lit';\nimport { customElement, property, queryAssignedElements, } from 'lit/decorators.js';\nimport AsyncValidator from 'async-validator';\nimport Checkbox from '../checkbox';\nimport styles from './style/form-item.scss';\nimport { ValueState } from '../types';\nlet FormItem = class FormItem extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {Array<Rule>}\n         * @defaultValue []\n         * @public\n         */\n        this.rules = [];\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    _handleChange(e) {\n        this.value = e.detail;\n        this.validateRules();\n    }\n    _handleSlotChange() {\n        const formControl = this.slotEls?.[0];\n        if (formControl) {\n            formControl.id = this.name;\n        }\n    }\n    async _validateRule(rule) {\n        const validator = new AsyncValidator({\n            [this.name]: [rule],\n        });\n        let result = [];\n        try {\n            await Promise.resolve(validator.validate({ [this.name]: this.value }));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (errObj) {\n            if (errObj.errors) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                result = errObj.errors.map(({ message }) => {\n                    return message;\n                });\n            }\n        }\n        return result;\n    }\n    validateRules() {\n        // eslint-disable-next-line no-async-promise-executor\n        const promise = new Promise(async (resolve, reject) => {\n            for (let i = 0; i < this.rules.length; i++) {\n                const errors = await this._validateRule(this.rules[i]);\n                if (errors.length) {\n                    reject(errors);\n                    break;\n                }\n            }\n            resolve([]);\n        });\n        promise\n            .catch((e) => e)\n            .then((ruleErrors) => {\n            if (!(this.slotEls[0] instanceof Checkbox)) {\n                const input = this.slotEls[0];\n                if (ruleErrors.length > 0) {\n                    input.valueState = ValueState.Error;\n                    input.valueStateMessage = ruleErrors[0];\n                }\n                else {\n                    input.valueState = ValueState.None;\n                }\n            }\n        });\n        return promise;\n    }\n    updated(changedProperties) {\n        if (changedProperties.has('value')) {\n            if (this.slotEls[0] instanceof Checkbox) {\n                this.slotEls[0].checked = this.value;\n            }\n            else {\n                this.slotEls[0].value = this.value;\n            }\n        }\n    }\n    render() {\n        const labelNode = this.label\n            ? html `<div class=\"stylospectrum-form-item-label-wrapper\">\n          <stylospectrum-label show-colon for=\"${this.name}\">\n            ${this.label}\n          </stylospectrum-label>\n          <slot name=\"suffix-label\"></slot>\n        </div>`\n            : nothing;\n        return html `\n      <div class=\"stylospectrum-form-item\">\n        ${labelNode}\n        <slot\n          @slotchange=${this._handleSlotChange}\n          @change=\"${this._handleChange}\"\n        >\n        </slot>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property()\n], FormItem.prototype, \"name\", void 0);\n__decorate([\n    property()\n], FormItem.prototype, \"label\", void 0);\n__decorate([\n    property()\n], FormItem.prototype, \"value\", void 0);\n__decorate([\n    property({ type: Array, reflect: false })\n], FormItem.prototype, \"rules\", void 0);\n__decorate([\n    queryAssignedElements({ flatten: true })\n], FormItem.prototype, \"slotEls\", void 0);\nFormItem = __decorate([\n    customElement('stylospectrum-form-item')\n], FormItem);\nexport default FormItem;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html } from 'lit';\nimport { customElement, queryAssignedElements } from 'lit/decorators.js';\nimport { ValueState } from '../types';\nimport Input from '../input';\nimport FormItem from './form-item';\nlet Form = class Form extends LitElement {\n    getFormItems() {\n        return this.slotEls.filter((el) => el instanceof FormItem);\n    }\n    getFieldsValue() {\n        const values = this.getFormItems().map((el) => [el.name, el.value]);\n        return Object.fromEntries(values);\n    }\n    setFieldsValue(values) {\n        const formItems = Object.fromEntries(this.getFormItems().map((el) => [el.name, el]));\n        Object.keys(values).forEach((key) => {\n            formItems[key].value = values[key];\n        });\n    }\n    resetFields() {\n        const formItems = this.getFormItems();\n        const values = Object.fromEntries(this.getFormItems().map((el) => [el.name, undefined]));\n        this.setFieldsValue(values);\n        formItems.forEach((item) => {\n            const slot = item.shadowRoot?.querySelector('slot');\n            const node = slot?.assignedElements({ flatten: true })?.[0];\n            if (node instanceof Input) {\n                node.valueState = ValueState.None;\n                node.valueStateMessage = '';\n            }\n        });\n    }\n    async validateFields() {\n        let hasError = false;\n        try {\n            await Promise.all(this.getFormItems().map((el) => el.validateRules()));\n        }\n        catch (e) {\n            hasError = true;\n        }\n        if (!hasError) {\n            return this.getFieldsValue();\n        }\n        return null;\n    }\n    render() {\n        return html `\n      <form class=\"stylospectrum-form\">\n        <slot></slot>\n      </form>\n    `;\n    }\n};\n__decorate([\n    queryAssignedElements({ flatten: true })\n], Form.prototype, \"slotEls\", void 0);\nForm = __decorate([\n    customElement('stylospectrum-form')\n], Form);\nexport default Form;\n","import { html } from 'lit';\nimport { createRef, ref } from 'lit/directives/ref.js';\nimport '.';\nimport './form-item';\nimport '../input';\nimport '../checkbox';\nimport '../button';\nimport '../link';\nconst Template = () => {\n    const formRef = createRef();\n    const passwordRef = createRef();\n    const forgotPassRef = createRef();\n    const createAnAccRef = createRef();\n    return html `\n    <stylospectrum-form ${ref(formRef)} style=\"width: 27.75rem; display:block\">\n      <stylospectrum-form-item\n        label=\"Email\"\n        name=\"email\"\n        .rules=\"${[\n        { required: true, message: 'Enter your email' },\n        {\n            pattern: /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$/,\n            message: 'Wrong or Invalid email address. Please correct and try again',\n        },\n    ]}\"\n      >\n        <stylospectrum-input\n          style=\"width: 100%\"\n          @keydown=\"${() => {\n        requestAnimationFrame(() => {\n            passwordRef.value?.shadowRoot?.querySelector('input')?.focus();\n        });\n    }}\"\n        ></stylospectrum-input>\n      </stylospectrum-form-item>\n\n      <stylospectrum-form-item\n        label=\"Password\"\n        name=\"password\"\n        .rules=\"${[{ required: true, message: 'Enter your password' }]}\"\n      >\n        <stylospectrum-link\n          ${ref(forgotPassRef)}\n          slot=\"suffix-label\"\n          @keydown=\"${() => {\n        requestAnimationFrame(() => {\n            createAnAccRef.value?.shadowRoot?.querySelector('a')?.focus();\n        });\n    }}\"\n        >\n          Forgot your password?\n        </stylospectrum-link>\n        <stylospectrum-input\n          style=\"width: 100%\"\n          ${ref(passwordRef)}\n          type=\"Password\"\n        >\n        </stylospectrum-input>\n      </stylospectrum-form-item>\n\n      <stylospectrum-form-item name=\"keep-me-signed-in\">\n        <stylospectrum-checkbox text=\"Keep me signed in\">\n        </stylospectrum-checkbox>\n      </stylospectrum-form-item>\n    </stylospectrum-form>\n\n    <stylospectrum-button\n      @click=${async () => console.log(await formRef.value?.validateFields())}\n      @keydown=\"${() => {\n        requestAnimationFrame(() => {\n            forgotPassRef.value?.shadowRoot?.querySelector('a')?.focus();\n        });\n    }}\"\n    >\n      Submit\n    </stylospectrum-button>\n    <br />\n    <stylospectrum-link ${ref(createAnAccRef)}>\n      Create an account!\n    </stylospectrum-link>\n  `;\n};\nexport default {\n    title: 'Form',\n    component: 'stylospectrum-form',\n    tags: ['autodocs'],\n};\nexport const Basic = Template.bind({});\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property, state } from 'lit/decorators.js';\nimport { ifDefined } from 'lit/directives/if-defined.js';\nimport styles from './style/index.scss';\nlet Link = class Link extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    constructor() {\n        super();\n        this._dummyAnchor = document.createElement('a');\n    }\n    _isCrossOrigin() {\n        const loc = window.location;\n        this._dummyAnchor.href = this.href;\n        return !(this._dummyAnchor.hostname === loc.hostname &&\n            this._dummyAnchor.port === loc.port &&\n            this._dummyAnchor.protocol === loc.protocol);\n    }\n    willUpdate() {\n        const needsNoReferrer = this.target !== '_self' && this.href && this._isCrossOrigin();\n        this._rel = needsNoReferrer ? 'noreferrer noopener' : undefined;\n    }\n    _handleFocusIn() {\n        this.focused = true;\n    }\n    _handleFocusOut() {\n        this.focused = false;\n    }\n    _handleClick(e) {\n        if (!this.href) {\n            e.preventDefault();\n        }\n    }\n    render() {\n        return html `\n      <a\n        class=\"stylospectrum-link\"\n        href=${this.href || '#'}\n        target=${ifDefined(this.target)}\n        rel=${ifDefined(this._rel)}\n        tabindex=${this.disabled ? '-1' : '0'}\n        title=\"${ifDefined(this.title || undefined)}\"\n        ?disabled=${this.disabled}\n        @click=${this._handleClick}\n        @focusin=${this._handleFocusIn}\n        @focusout=${this._handleFocusOut}\n      >\n        <slot></slot>\n      </a>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean })\n], Link.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Link.prototype, \"href\", void 0);\n__decorate([\n    property()\n], Link.prototype, \"target\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Link.prototype, \"focused\", void 0);\n__decorate([\n    state()\n], Link.prototype, \"_rel\", void 0);\nLink = __decorate([\n    customElement('stylospectrum-link')\n], Link);\nexport default Link;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { TooltipPlacement } from '../types';\nlet Tooltip = class Tooltip extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    connectedCallback() {\n        super.connectedCallback();\n        setTimeout(() => {\n            const openerRect = JSON.parse(this.openerRect);\n            this.style.left =\n                openerRect.left + (openerRect.width - this.offsetWidth) / 2 + 'px';\n            if (this.placement === TooltipPlacement.Top) {\n                this.style.top = openerRect.top - this.offsetHeight - 8 + 'px';\n            }\n            else {\n                this.style.top = openerRect.bottom + 8 + 'px';\n            }\n        });\n    }\n    render() {\n        return html `\n      <div class=\"stylospectrum-tooltip\">\n        <div class=\"stylospectrum-tooltip-text\">\n          <slot></slot>\n        </div>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property({ type: String, reflect: false })\n], Tooltip.prototype, \"openerRect\", void 0);\n__decorate([\n    property({ type: String })\n], Tooltip.prototype, \"placement\", void 0);\nTooltip = __decorate([\n    customElement('stylospectrum-tooltip')\n], Tooltip);\nexport default Tooltip;\n"],"names":[],"sourceRoot":""}