{"version":3,"file":"popover-stories.7bfef9d4.iframe.bundle.js","mappings":";;AA+BA;AACA;;AAWA;;AAGA;;AAMA;;AAMA;AACA;;AAEA;AACA;AACA;;AAEA;;AAGA;ACrDA;AACA;AAIA;AAIA;;;;;AAOA;;;;;;AAOA;AC6EA;AACA;AA4IA;;AAGA;;;;;;;AAQA;;;;AAKA;;;;;;;;;;;AAYA;ACjRA;;AAEA;;;;;;;;;AASA;;;;AAIA;;;;;;;;;AASA;;;;;;AAMA","sources":["webpack://@stylospectrum/ui/./src/button/index.ts","webpack://@stylospectrum/ui/./src/list/list-item.ts","webpack://@stylospectrum/ui/./src/popover/index.ts","webpack://@stylospectrum/ui/./src/popover/stories.ts"],"sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { ButtonDesign, ButtonType } from '../types';\nimport styles from './style/index.scss';\nimport '../icon';\nlet Button = class Button extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * @type {ButtonDesign}\n         * @defaultValue \"Primary\"\n         * @public\n         */\n        this.type = ButtonDesign.Primary;\n        /**\n         * Defines whether the button has special form-related functionality.\n         *\n         * @type {ButtonType}\n         * @defaultValue \"Button\"\n         * @public\n         */\n        this.htmlType = ButtonType.Button;\n    }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    handleFocusIn() {\n        this.focused = true;\n    }\n    handleFocusOut() {\n        this.focused = false;\n    }\n    render() {\n        const iconNode = this.icon\n            ? html `<stylospectrum-icon\n          class=\"stylospectrum-button-icon\"\n          name=${this.icon}\n        >\n        </stylospectrum-icon>`\n            : html `<slot name=\"icon\"></slot>`;\n        const textNode = this.icon\n            ? nothing\n            : html `<span class=\"stylospectrum-button-text\">\n          <slot></slot>\n        </span>`;\n        const classes = {\n            'stylospectrum-button': true,\n            'stylospectrum-button-has-icon': !!this.icon,\n        };\n        return html `\n      <button\n        ?disabled=${this.disabled}\n        type=${this.htmlType.toLowerCase()}\n        part=\"button\"\n        class=${classMap(classes)}\n        @focusout=${this.handleFocusOut}\n        @focusin=${this.handleFocusIn}\n      >\n        ${textNode} ${iconNode}\n      </button>\n    `;\n    }\n};\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"disabled\", void 0);\n__decorate([\n    property()\n], Button.prototype, \"icon\", void 0);\n__decorate([\n    property({ type: String, reflect: true })\n], Button.prototype, \"type\", void 0);\n__decorate([\n    property({ type: String, attribute: 'html-type', reflect: true })\n], Button.prototype, \"htmlType\", void 0);\n__decorate([\n    property({ type: Boolean, reflect: true })\n], Button.prototype, \"focused\", void 0);\nButton = __decorate([\n    customElement('stylospectrum-button')\n], Button);\nexport default Button;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, css, unsafeCSS } from 'lit';\nimport { customElement, property } from 'lit/decorators.js';\nimport { consume } from '@lit/context';\nimport { classMap } from 'lit/directives/class-map.js';\nimport { listContext } from './context';\nimport styles from './style/list-item.scss';\nimport '../icon';\nlet ListItem = class ListItem extends LitElement {\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    render() {\n        const selected = this._consumer?.selectedId === this.id;\n        return html `<div\n      class=${classMap({\n            'stylospectrum-list-item': true,\n            'stylospectrum-list-item-selected': selected,\n        })}\n      @click=${() => {\n            this._consumer?.onChangeId?.(this.id);\n        }}\n    >\n      <span class=\"stylospectrum-list-item-icon-wrapper\">\n        <stylospectrum-icon\n          class=\"stylospectrum-list-item-icon\"\n          name=\"${this.icon}\"\n        >\n        </stylospectrum-icon>\n      </span>\n\n      <span class=\"stylospectrum-list-item-text\"><slot></slot></span>\n    </div>`;\n    }\n};\n__decorate([\n    property({ type: String })\n], ListItem.prototype, \"icon\", void 0);\n__decorate([\n    consume({ context: listContext, subscribe: true })\n], ListItem.prototype, \"_consumer\", void 0);\nListItem = __decorate([\n    customElement('stylospectrum-list-item')\n], ListItem);\nexport default ListItem;\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar Popover_1;\nimport { LitElement, html, css, unsafeCSS, nothing } from 'lit';\nimport { customElement, property, query, queryAssignedElements, state, } from 'lit/decorators.js';\nimport styles from './style/index.scss';\nimport { PopoverHorizontalAlign } from '../types';\nimport clamp from '../utils/clamp';\nimport getParentElement from '../utils/getParentElement';\nimport isElementContainingBlock from '../utils/isElementContainingBlock';\nimport { getFocusedElement, isClickInRect } from '../utils/popup';\nimport { getFirstFocusableElement } from '../utils/focusableElements';\nconst ARROW_SIZE = 8;\nconst openedRegistry = [];\nlet Popover = class Popover extends LitElement {\n    constructor() {\n        super(...arguments);\n        /**\n         * Determines the horizontal alignment of the component.\n         *\n         * @type {PopoverHorizontalAlign}\n         * @defaultValue \"Center\"\n         * @public\n         */\n        this.horizontalAlign = PopoverHorizontalAlign.Center;\n        /**\n         * @type {number}\n         * @defaultValue 0\n         * @private\n         */\n        this.offsetX = 0;\n        this.arrowTranslateX = 0;\n        this.arrowTranslateY = 0;\n        this.opened = false;\n        this._clickHandler = (event) => {\n            const openedPopups = [...openedRegistry];\n            if (openedPopups.length === 0) {\n                return;\n            }\n            const isTopPopupPopover = openedPopups[openedPopups.length - 1].instance instanceof Popover_1;\n            if (!isTopPopupPopover) {\n                return;\n            }\n            for (let i = openedPopups.length - 1; i !== -1; i--) {\n                const popup = openedPopups[i].instance;\n                if (popup._isOpenerClicked(event)) {\n                    return;\n                }\n                if (isClickInRect(event, popup.popup.getBoundingClientRect())) {\n                    break;\n                }\n                popup.hide();\n            }\n        };\n        this._attachGlobalClickHandler = () => {\n            document.addEventListener('mousedown', this._clickHandler);\n        };\n        this._detachGlobalClickHandler = () => {\n            document.removeEventListener('mousedown', this._clickHandler);\n        };\n        this._getParentPopoversIfNested = (instance) => {\n            let currentElement = instance.parentNode;\n            const parentPopovers = [];\n            while (currentElement && currentElement.parentNode) {\n                for (let i = 0; i < openedRegistry.length; i++) {\n                    if (currentElement === openedRegistry[i].instance) {\n                        parentPopovers.push(currentElement);\n                    }\n                }\n                currentElement = currentElement.parentNode;\n            }\n            return parentPopovers;\n        };\n        this._addOpenedPopover = (instance) => {\n            const parentPopovers = this._getParentPopoversIfNested(instance);\n            openedRegistry.push({\n                instance,\n                parentPopovers,\n            });\n            if (openedRegistry.length === 1) {\n                this._attachGlobalClickHandler();\n            }\n        };\n        this._removeOpenedPopover = (instance) => {\n            const popoversToClose = [instance];\n            for (let i = 0; i < openedRegistry.length; i++) {\n                const indexOfCurrentInstance = openedRegistry[i].parentPopovers.indexOf(instance);\n                if (openedRegistry[i].parentPopovers.length > 0 &&\n                    indexOfCurrentInstance > -1) {\n                    popoversToClose.push(openedRegistry[i].instance);\n                }\n            }\n            for (let i = popoversToClose.length - 1; i >= 0; i--) {\n                for (let j = 0; j < openedRegistry.length; j++) {\n                    let indexOfItemToRemove = -1;\n                    if (popoversToClose[i] === openedRegistry[j].instance) {\n                        indexOfItemToRemove = j;\n                    }\n                    if (indexOfItemToRemove >= 0) {\n                        const itemToClose = openedRegistry.splice(indexOfItemToRemove, 1);\n                        itemToClose[0].instance.hide();\n                    }\n                }\n            }\n            if (!openedRegistry.length) {\n                this._detachGlobalClickHandler();\n            }\n        };\n    }\n    static { Popover_1 = this; }\n    static { this.styles = css `\n    ${unsafeCSS(styles)}\n  `; }\n    static get VIEWPORT_MARGIN() {\n        return 10; // px\n    }\n    _isOpenerClicked(e) {\n        const target = e.target;\n        if (target === this.opener?.[0]) {\n            return true;\n        }\n        return e.composedPath().indexOf(this.opener?.[0]) > -1;\n    }\n    _getContainingBlockClientLocation() {\n        let parentElement = getParentElement(this);\n        while (parentElement) {\n            if (isElementContainingBlock(parentElement)) {\n                return parentElement.getBoundingClientRect();\n            }\n            parentElement = getParentElement(parentElement);\n        }\n        return { left: 0, top: 0 };\n    }\n    _getPopupSize() {\n        const rect = this.popup.getBoundingClientRect(), width = rect.width, height = rect.height;\n        return { width, height };\n    }\n    _getVerticalLeft(targetRect, popoverSize) {\n        let left = 0;\n        switch (this.horizontalAlign) {\n            case PopoverHorizontalAlign.Center:\n                left = targetRect.left - (popoverSize.width - targetRect.width) / 2;\n                break;\n            case PopoverHorizontalAlign.Right:\n                left = targetRect.right - popoverSize.width + this.offsetX;\n                break;\n        }\n        return left;\n    }\n    _getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius) {\n        let arrowXCentered = this.horizontalAlign === PopoverHorizontalAlign.Center;\n        if (this.horizontalAlign === PopoverHorizontalAlign.Right &&\n            left <= targetRect.left) {\n            arrowXCentered = true;\n        }\n        let arrowTranslateX = 0;\n        if (isVertical && arrowXCentered) {\n            arrowTranslateX =\n                targetRect.left + targetRect.width / 2 - left - popoverSize.width / 2;\n        }\n        let arrowTranslateY = 0;\n        const safeRangeForArrowY = popoverSize.height / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateY = clamp(arrowTranslateY, -safeRangeForArrowY, safeRangeForArrowY);\n        const safeRangeForArrowX = popoverSize.width / 2 - borderRadius - ARROW_SIZE / 2;\n        arrowTranslateX = clamp(arrowTranslateX, -safeRangeForArrowX, safeRangeForArrowX);\n        return {\n            x: Math.round(arrowTranslateX),\n            y: Math.round(arrowTranslateY),\n        };\n    }\n    _calcPlacement(targetRect, popoverSize) {\n        const clientWidth = document.documentElement.clientWidth;\n        const isVertical = true;\n        const arrowOffset = ARROW_SIZE;\n        let left = this._getVerticalLeft(targetRect, popoverSize);\n        const top = targetRect.bottom + arrowOffset;\n        if (isVertical) {\n            if (popoverSize.width > clientWidth || left < 0) {\n                left = 0;\n            }\n            else if (left + popoverSize.width > clientWidth) {\n                left -= left + popoverSize.width - clientWidth;\n            }\n        }\n        if (this._left === undefined || Math.abs(this._left - left) > 1.5) {\n            this._left = Math.round(left);\n        }\n        if (this._top === undefined || Math.abs(this._top - top) > 1.5) {\n            this._top = Math.round(top);\n        }\n        const borderRadius = Number.parseInt(window.getComputedStyle(this).getPropertyValue('border-radius'));\n        const arrowPos = this._getArrowPosition(targetRect, popoverSize, left, isVertical, borderRadius);\n        return {\n            arrow: arrowPos,\n            top: this._top,\n            left: this._left,\n        };\n    }\n    resetFocus() {\n        if (!this._focusedElementBeforeOpen) {\n            return;\n        }\n        this._focusedElementBeforeOpen.focus();\n        this._focusedElementBeforeOpen = null;\n    }\n    show() {\n        if (this.opened) {\n            return;\n        }\n        const popupSize = this._getPopupSize();\n        const openerRect = this.opener?.[0].getBoundingClientRect();\n        if (popupSize.width === 0 || popupSize.height === 0) {\n            return;\n        }\n        const placement = this._calcPlacement(openerRect, popupSize);\n        let left = clamp(this._left, Popover_1.VIEWPORT_MARGIN, document.documentElement.clientWidth -\n            popupSize.width -\n            Popover_1.VIEWPORT_MARGIN);\n        let top = clamp(this._top, Popover_1.VIEWPORT_MARGIN, document.documentElement.clientHeight -\n            popupSize.height -\n            Popover_1.VIEWPORT_MARGIN);\n        top = Math.max(top, this._top);\n        this.arrowTranslateX = placement.arrow.x;\n        this.arrowTranslateY = placement.arrow.y;\n        const containingBlockClientLocation = this._getContainingBlockClientLocation();\n        left -= containingBlockClientLocation.left;\n        top -= containingBlockClientLocation.top;\n        this._addOpenedPopover(this);\n        this.opened = true;\n        this._focusedElementBeforeOpen = getFocusedElement();\n        const ele = getFirstFocusableElement(this);\n        ele?.focus();\n        Object.assign(this.popup.style, {\n            top: `${top}px`,\n            left: `${left}px`,\n        });\n    }\n    hide() {\n        if (!this.opened) {\n            return;\n        }\n        this._removeOpenedPopover(this);\n        this.opened = false;\n        this.resetFocus();\n        Object.assign(this.popup.style, {\n            top: '-10000px',\n            left: '-10000px',\n        });\n    }\n    render() {\n        const headerNode = this.headerText\n            ? html `<header class=\"stylospectrum-popover-header\" part=\"header\">\n          <h1 class=\"stylospectrum-popover-header-text\">${this.headerText}</h1>\n          <slot name=\"sub-header\"></slot>\n        </header>`\n            : nothing;\n        return html `\n      <slot name=\"opener\"></slot>\n\n      <div class=\"stylospectrum-popover-wrapper\">\n        <section class=\"stylospectrum-popover\">\n          <span\n            class=\"stylospectrum-popover-arrow\"\n            style=\"transform:translate(${this.arrowTranslateX}px, ${this\n            .arrowTranslateY}px)\"\n          >\n          </span>\n\n          ${headerNode}\n\n          <div part=\"content\" class=\"stylospectrum-popover-content\">\n            <slot></slot>\n          </div>\n\n          <footer part=\"footer\" class=\"stylospectrum-popover-footer\">\n            <slot name=\"footer\"></slot>\n          </footer>\n        </section>\n      </div>\n    `;\n    }\n};\n__decorate([\n    property({ type: String, attribute: 'header-text' })\n], Popover.prototype, \"headerText\", void 0);\n__decorate([\n    property({ type: String, attribute: 'horizontal-align' })\n], Popover.prototype, \"horizontalAlign\", void 0);\n__decorate([\n    property({ type: Number, attribute: 'offset-x' })\n], Popover.prototype, \"offsetX\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateX\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"arrowTranslateY\", void 0);\n__decorate([\n    state()\n], Popover.prototype, \"opened\", void 0);\n__decorate([\n    queryAssignedElements({ slot: 'opener' })\n], Popover.prototype, \"opener\", void 0);\n__decorate([\n    query('.stylospectrum-popover-wrapper')\n], Popover.prototype, \"popup\", void 0);\nPopover = Popover_1 = __decorate([\n    customElement('stylospectrum-popover')\n], Popover);\nexport default Popover;\n","import { html } from 'lit';\nimport { createRef, ref } from 'lit/directives/ref.js';\nimport '.';\nimport '../list/list-item';\nimport '../button';\nimport '../input';\nimport '../icon/data/account';\nconst Template = () => {\n    const popoverRef = createRef();\n    const popoverRef_1 = createRef();\n    return html `\n    <stylospectrum-popover ${ref(popoverRef)} header-text=\"Header\">\n      <stylospectrum-button\n        @click=${() => popoverRef.value?.show()}\n        slot=\"opener\"\n      >\n        Open Popover\n      </stylospectrum-button>\n\n      <stylospectrum-input slot=\"sub-header\" show-search> </stylospectrum-input>\n\n      <div>\n        <stylospectrum-popover ${ref(popoverRef_1)} header-text=\"Header\">\n          <stylospectrum-list-item\n            slot=\"opener\"\n            icon=\"account\"\n            @click=${() => popoverRef_1.value?.show()}\n          >\n            Open Popover\n          </stylospectrum-list-item>\n          <div style=\"padding:1rem\">Content</div>\n        </stylospectrum-popover>\n\n        <stylospectrum-list-item\n          icon=\"account\"\n          @click=${() => popoverRef.value?.hide()}\n        >\n          Close Popover\n        </stylospectrum-list-item>\n      </div>\n    </stylospectrum-popover>\n  `;\n};\nexport default {\n    title: 'Popover',\n    component: 'stylospectrum-popover',\n    tags: ['autodocs'],\n    argTypes: {\n        horizontalAlign: {\n            control: 'select',\n            options: ['Center', 'Right'],\n        },\n    },\n};\nexport const Basic = Template.bind({});\nBasic.args = {};\n"],"names":[],"sourceRoot":""}